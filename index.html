<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MonoWeather</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/weather-icons/2.0.12/css/weather-icons.min.css">
    <!-- Tabler Icons (webfont) for mobile slider icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@tabler/icons-webfont@latest/tabler-icons.min.css">

    <!-- Leaflet (for Radar Map) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        :root {
            --accent-color: #f97316;
            --bg-color: #f4f4f5; /* Zinc-100 */
            --text-color: #18181b; /* Zinc-900 */
            --card-bg: rgba(255, 255, 255, 0.95);
            --card-border: rgba(0,0,0,0.1);
            --handle-bg: #18181b;
            --handle-text: #f4f4f5;
        }

        body.dark-mode {
            --bg-color: #18181b;
            --text-color: #e4e4e7;
            --card-bg: rgba(24, 24, 27, 0.95); /* Zinc-900 */
            --card-border: rgba(255,255,255,0.1);
            --handle-bg: #e4e4e7;
            --handle-text: #18181b;
        }

        body {
            font-family: 'Space Mono', monospace;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
            overflow: hidden; 
        }

        /* Accent Utilities */
        .text-accent { color: var(--accent-color); }
        .bg-accent { background-color: var(--accent-color); }
        .border-accent { border-color: var(--accent-color); }
        .hover\:bg-accent:hover { background-color: var(--accent-color); }
        .hover\:border-accent:hover { border-color: var(--accent-color); }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: var(--card-border); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--accent-color); }

        /* Weather Card */
        .weather-card {
            background: var(--card-bg);
            border: 2px solid var(--text-color);
            border-left-width: 6px; 
            box-shadow: 4px 4px 0px var(--card-border);
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s, background-color 0.2s;
            cursor: pointer;
        }
        .weather-card.interactive:hover {
            transform: translate(-2px, -2px);
            box-shadow: 6px 6px 0px var(--card-border);
            border-color: var(--accent-color);
        }

        /* Slider */
        #nav-slider { user-select: none; z-index: 50; }
        
        /* Track Line - Desktop (Pinned Left) */
        .slider-track-line {
            position: absolute;
            left: 3.5rem; /* Center of w-28 (7rem) is 3.5rem */
            top: 2rem;
            bottom: 2rem;
            width: 4px;
            background: var(--card-border);
            z-index: 0;
            border-radius: 2px;
            transform: translateX(-50%);
        }
        
        /* The Handle (Desktop default) */
        #slider-handle {
            position: absolute;
            left: 3.5rem; /* Center of w-28 */
            transform: translate(-50%, -50%); 
            width: 48px;
            height: 48px;
            background: var(--accent-color);
            border: 4px solid var(--text-color);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            color: var(--handle-text); 
            box-shadow: 4px 4px 0px rgba(0,0,0,0.2);
            cursor: grab;
            transition: top 0.3s cubic-bezier(0.25, 1, 0.5, 1), left 0.3s cubic-bezier(0.25, 1, 0.5, 1), width 0.3s ease, transform 0.3s ease;
            overflow: hidden;
            white-space: nowrap;
        }
        
        /* Expand Handle on Hover (Desktop only; nav uses md:hover) */
        #nav-slider:hover #slider-handle {
            width: 180px;
            justify-content: flex-start;
            padding-left: 0.75rem;
            z-index: 60;
            transform: translate(0, -50%);
            left: 2rem;
        }
        
        #slider-handle.dragging {
            cursor: grabbing;
            transition: width 0.3s ease;
        }

        /* Ticks (Desktop default) */
        .tick-hitbox {
            position: relative;
            z-index: 10;
            height: 96px; 
            width: 100%;
            display: flex;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            padding-left: 0;
        }
        
        /* Icon Box (Desktop) */
        .tick-icon-box {
            width: 7rem;
            display: flex;
            justify-content: center;
            flex-shrink: 0;
            transition: all 0.3s ease;
        }

        /* Mobile: bottom horizontal slider */
        @media (max-width: 767px) {
            .slider-track-line {
                left: 1rem;
                right: 1rem;
                top: 50%;
                bottom: auto;
                width: auto;
                height: 4px;
                transform: translateY(-50%);
            }

            #slider-handle {
                top: 50% !important;
                left: 0;
                transform: translate(-50%, -50%);
                transition: left 0.3s cubic-bezier(0.25, 1, 0.5, 1), width 0.3s ease, transform 0.3s ease;
            }

            /* No hover expansion on mobile */
            #nav-slider:hover #slider-handle {
                width: 48px;
                padding-left: 0;
                justify-content: center;
                transform: translate(-50%, -50%);
                left: 0;
            }

            .tick-hitbox {
                height: 100%;
                width: auto;
                flex: 1;
                justify-content: center;
                margin-bottom: 0 !important;
            }

            .tick-icon-box {
                width: auto;
            }

            /* Mobile: keep page-name labels hidden (icons only, no hover tooltips) */
            #handle-text { display: none; }
            .nav-label { display: none; }
        }

        .tick-hitbox:hover .tick-icon {
            color: var(--accent-color);
            transform: scale(1.1);
        }
        .tick-icon {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-color);
            border: 3px solid var(--card-border);
            transition: all 0.2s;
        }
        
        /* Label transitions */
        .nav-label {
            opacity: 0;
            font-weight: bold;
            font-size: 1rem;
            white-space: nowrap;
            transition: opacity 0.2s 0.1s;
            overflow: hidden;
            margin-left: 0.5rem;
        }
        #nav-slider:hover .nav-label {
            opacity: 1;
        }
        
        /* Handle Text */
        #handle-text {
            opacity: 0;
            margin-left: 0.5rem;
            font-weight: bold;
            font-size: 1rem;
            transition: opacity 0.2s;
        }
        #nav-slider:hover #handle-text {
            opacity: 1;
        }

        /* Modal */
        dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--card-bg);
            color: var(--text-color);
            border: 4px solid var(--text-color);
            box-shadow: 10px 10px 0px rgba(0,0,0,0.3);
            padding: 0;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            margin: 0; 
            z-index: 100;
        }
        dialog::backdrop {
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
        }
        
        /* Scales */
        .vis-bar { transition: height 0.3s; }
        
        .loader {
            width: 48px;
            height: 48px;
            border: 5px solid rgba(128,128,128,0.3);
            border-bottom-color: var(--accent-color);
            border-radius: 50%;
            display: inline-block;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }
        @keyframes rotation {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .blink { animation: blinker 1.5s linear infinite; }
        @keyframes blinker { 50% { opacity: 0; } }

        /* Radar overlay squiggle loader (continuous scroll, clipped) */
        .squiggle-wrap {
            width: 160px;
            height: 20px;
            overflow: hidden;
        }
        .squiggle-svg {
            width: 1920px; /* long strip */
            height: 20px;
            animation: squiggle-scroll 6s linear infinite;
            will-change: transform;
        }
        @keyframes squiggle-scroll {
            from { transform: translateX(0); }
            /* 1920px strip inside 160px window => travel ~1760px */
            to { transform: translateX(-1760px); }
        }

        /* Radar placeholder background */
        .radar-placeholder {
            background:
                linear-gradient(to right, rgba(0,0,0,0.08) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(0,0,0,0.08) 1px, transparent 1px),
                radial-gradient(circle at 50% 50%, rgba(249,115,22,0.14), transparent 55%);
            background-size: 24px 24px, 24px 24px, 100% 100%;
            filter: saturate(0.9);
        }
        body.dark-mode .radar-placeholder {
            background:
                linear-gradient(to right, rgba(255,255,255,0.10) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(255,255,255,0.10) 1px, transparent 1px),
                radial-gradient(circle at 50% 50%, rgba(249,115,22,0.16), transparent 55%);
            background-size: 24px 24px, 24px 24px, 100% 100%;
            filter: saturate(0.9);
        }

        /* Leaflet styling to match MonoWeather */
        #radar-map {
            width: 100%;
            height: 100%;
            background: var(--bg-color);
        }
        .leaflet-container {
            font-family: 'Space Mono', monospace;
        }
        .leaflet-control-zoom a {
            border-radius: 0 !important;
            background: var(--card-bg) !important;
            color: var(--text-color) !important;
            border: 2px solid var(--text-color) !important;
            box-shadow: 3px 3px 0px var(--card-border) !important;
        }
        .leaflet-control-attribution {
            font-family: 'Space Mono', monospace;
            background: transparent !important;
            color: rgba(0,0,0,0.5) !important;
        }
        body.dark-mode .leaflet-control-attribution {
            color: rgba(255,255,255,0.6) !important;
        }
        .leaflet-control-attribution a {
            color: var(--accent-color) !important;
            font-weight: bold;
        }
        .leaflet-control-layers {
            border-radius: 0 !important;
            background: var(--card-bg) !important;
            color: var(--text-color) !important;
            border: 2px solid var(--text-color) !important;
            box-shadow: 3px 3px 0px var(--card-border) !important;
        }

        /* Radar overlay panel (theme-native; map already switches to dark tiles in dark mode) */
        .radar-status-panel {
            background: var(--card-bg);
            color: var(--text-color);
            border: 4px solid var(--text-color);
            box-shadow: 8px 8px 0 rgba(0,0,0,0.22);
            max-width: 520px;
        }

        /* Radar TEMP grid labels (no box; match °C/°F setting; theme-native color) */
        .temp-div-icon {
            background: transparent !important;
            border: none !important;
        }
        .temp-grid-label {
            font-family: 'Space Mono', monospace;
            font-weight: 700;
            font-size: 10px;
            line-height: 1;
            color: var(--text-color);
            opacity: 0.78;
            transform: translate(-50%, -50%);
            white-space: nowrap;
            background: transparent;
            border: none;
            padding: 0;
            box-shadow: none;
            text-shadow: 0 1px 0 rgba(0,0,0,0.30), 0 -1px 0 rgba(255,255,255,0.18);
        }

        /* Ensure nav icons inherit proper color + font size */
        .tick-icon i { display: inline-block; }

        /* Desktop: hide icon glyphs (keep mechanical squares + hover labels) */
        @media (min-width: 768px) {
            .tick-icon i { display: none; }
            #handle-icon { display: none; }
            /* remove leftover spacing that assumed an icon */
            #handle-text { margin-left: 0; }
        }
    </style>
</head>
<body class="flex flex-col md:flex-row h-screen w-full select-none overflow-hidden text-[var(--text-color)] bg-[var(--bg-color)]">

    <!-- Slider Navigation (vertical on desktop, horizontal bottom bar on mobile) -->
    <nav id="nav-slider" class="fixed bottom-0 left-0 w-full h-24 md:relative md:h-full md:w-28 flex-shrink-0 border-t-2 md:border-t-0 md:border-r-2 border-[var(--card-border)] bg-[var(--bg-color)] group md:hover:w-64 transition-all duration-300">
        
        <!-- Track Line -->
        <div class="slider-track-line"></div>

        <!-- Ticks Container -->
        <div class="relative h-full flex flex-row md:flex-col w-full py-0 md:py-12 px-4 md:px-0 items-center justify-between md:justify-start" id="ticks-container">
            <!-- Items injected by JS -->
        </div>

        <!-- The Handle -->
        <div id="slider-handle">
            <i id="handle-icon" class="wi wi-day-sunny text-2xl text-[var(--handle-text)]"></i>
            <span id="handle-text">WEATHER</span>
        </div>
    </nav>

    <!-- Main Content Area -->
    <main class="flex-1 relative overflow-hidden bg-[var(--bg-color)] pb-24 md:pb-0">
        
        <!-- Page Container -->
        <div id="page-container" class="absolute top-0 left-0 w-full h-full flex flex-col">
            
            <!-- PAGE 0: WEATHER -->
            <section class="w-full h-full overflow-y-auto p-6 md:p-12 flex flex-col items-center">
                <div class="w-full max-w-6xl pb-24">
                    
                    <!-- Search Header -->
                    <div class="mb-12 relative z-[60] w-full max-w-3xl mx-auto">
                        <div class="flex items-center border-b-4 border-current pb-2 transition-colors focus-within:border-accent">
                            <input 
                                type="text" 
                                id="city-search" 
                                placeholder="SEARCH CITY..." 
                                class="w-full bg-transparent text-3xl md:text-5xl font-bold outline-none placeholder:opacity-30 uppercase font-mono tracking-tighter"
                                autocomplete="off"
                            >
                            <button id="search-btn" class="ml-4 hover:text-accent transition-colors">
                                <span class="text-5xl md:text-6xl">→</span>
                            </button>
                        </div>
                        <div id="error-msg" class="text-red-500 font-bold mt-2 text-sm h-5"></div>
                        
                        <!-- Search Dropdown -->
                        <div id="search-dropdown" class="absolute top-full left-0 w-full max-w-full bg-[var(--card-bg)] border-4 border-t-0 border-[var(--text-color)] hidden shadow-2xl max-h-96 overflow-y-auto z-[60]">
                            <!-- Items injected here -->
                        </div>
                    </div>

                    <!-- Loading -->
                    <div id="loading-state" class="hidden text-center py-20">
                        <span class="loader"></span>
                        <p class="mt-8 blink text-xl">ACQUIRING_SIGNAL...</p>
                    </div>

                    <!-- Weather Content -->
                    <div id="weather-content" class="hidden animate-fade-in space-y-8">
                        
                        <!-- Main Card -->
                        <div class="w-full border-4 border-[var(--text-color)] border-l-[16px] border-l-accent bg-[var(--card-bg)] p-8 relative shadow-[8px_8px_0px_rgba(0,0,0,0.1)] mb-12">
                            <div class="flex flex-row justify-between items-start sm:items-center gap-4 md:gap-8">
                                <!-- Left: Location & Description -->
                                <div class="flex-1 min-w-0">
                                    <h2 id="city-display" class="text-4xl sm:text-5xl md:text-7xl font-bold uppercase leading-none tracking-tighter break-words">--</h2>
                                    <p id="date-display" class="text-base sm:text-lg md:text-xl opacity-60 mt-2 font-bold">--</p>
                                    <p id="desc-display" class="mt-4 sm:mt-6 text-xl sm:text-2xl md:text-3xl font-bold uppercase text-accent border-l-8 border-accent pl-4 sm:pl-6">--</p>
                                </div>
                                <!-- Right: Icon & Temperature -->
                                <div class="text-center flex flex-col items-end flex-shrink-0">
                                    <i id="main-icon" class="wi wi-day-sunny text-6xl sm:text-7xl md:text-7xl leading-none text-accent"></i>
                                    <div class="mt-3 sm:mt-4 flex items-start justify-center">
                                        <span id="temp-display" class="text-6xl sm:text-7xl md:text-9xl font-bold leading-none tracking-tighter">--</span>
                                        <span id="unit-display" class="text-2xl sm:text-3xl md:text-4xl font-bold mt-3 sm:mt-4">°C</span>
                                    </div>
                                    <div class="mt-3 sm:mt-4 flex gap-4 sm:gap-6 text-lg sm:text-xl md:text-2xl font-bold opacity-80">
                                        <span>H: <span id="high-display">--</span>°</span>
                                        <span class="opacity-50">L: <span id="low-display">--</span>°</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Details Grid -->
                        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">

                            <!-- Temperature (Feels Like) -->
                            <div class="weather-card interactive p-6 flex flex-col justify-between h-48" onclick="showDetail('TEMPERATURE', '', 'Today\'s temperature vs feels-like trend. High/Low are highlighted.', 'wi wi-thermometer')">
                                <div class="flex justify-between items-start">
                                    <div class="flex flex-col">
                                        <span class="text-sm font-bold opacity-50">TEMPERATURE</span>
                                        <span id="temp-desc" class="text-xs font-bold text-accent mt-1">--</span>
                                    </div>
                                    <i class="wi wi-thermometer text-4xl text-accent"></i>
                                </div>
                                <div>
                                    <div class="text-xs font-bold opacity-50">FEELS LIKE</div>
                                    <div class="text-3xl font-bold"><span id="feelslike-display">--</span><span class="text-lg ml-1">°</span></div>
                                </div>
                            </div>
                            
                            <!-- Wind -->
                            <div class="weather-card interactive p-6 flex flex-col justify-between h-48" onclick="showDetail('WIND', els.wind.innerText + ' ' + (state.windSpeedUnit === 'mph' ? 'mph' : 'km/h'), 'Wind speed and direction.', 'wi wi-strong-wind')">
                                <div class="flex justify-between items-start w-full">
                                    <div class="flex flex-col">
                                        <span class="text-sm font-bold opacity-50">WIND</span>
                                        <span id="wind-desc" class="text-xs font-bold text-accent mt-1">--</span>
                                    </div>
                                    <i class="wi wi-strong-wind text-4xl text-accent"></i>
                                </div>
                                <div class="flex items-center gap-4 mt-2">
                                    <!-- Compass -->
                                    <div class="relative w-16 h-16 border-4 border-current rounded-full flex items-center justify-center shrink-0">
                                        <div class="absolute top-1 left-1/2 -translate-x-1/2 text-[0.6rem] font-bold bg-[var(--card-bg)] z-10 px-0.5 leading-none">N</div>
                                        <div class="absolute bottom-1 left-1/2 -translate-x-1/2 text-[0.6rem] font-bold bg-[var(--card-bg)] z-10 px-0.5 leading-none">S</div>
                                        <div class="absolute left-1 top-1/2 -translate-y-1/2 text-[0.6rem] font-bold bg-[var(--card-bg)] z-10 px-0.5 leading-none">W</div>
                                        <div class="absolute right-1 top-1/2 -translate-y-1/2 text-[0.6rem] font-bold bg-[var(--card-bg)] z-10 px-0.5 leading-none">E</div>
                                        <!-- SVG Arrow -->
                                        <svg id="wind-compass" viewBox="0 0 24 24" class="w-8 h-8 text-accent transition-transform duration-500 z-20" style="transform-origin: 50% 50%;">
                                            <path d="M12 3L12 21M12 3L7 10M12 3L17 10" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                                        </svg>
                                    </div>
                                    <div class="flex flex-col">
                                        <span class="text-3xl font-bold truncate"><span id="wind-display">--</span></span>
                                        <span class="text-sm opacity-50 unit-wind">km/h</span>
                                    </div>
                                </div>
                            </div>

                            <!-- Humidity -->
                            <div class="weather-card interactive p-6 flex flex-col justify-between h-48" onclick="showDetail('HUMIDITY', els.humidity.innerText + '%', 'Relative humidity at 2m height.', 'wi wi-raindrops')">
                                <div class="flex justify-between items-start">
                                    <div class="flex flex-col">
                                        <span class="text-sm font-bold opacity-50">HUMIDITY</span>
                                        <span id="hum-desc" class="text-xs font-bold text-accent mt-1">--</span>
                                    </div>
                                    <i class="wi wi-raindrops text-4xl text-accent"></i>
                                </div>
                                <div>
                                    <span class="text-3xl font-bold"><span id="humidity-display">--</span><span class="text-lg ml-1">%</span></span>
                                    <div class="w-full h-3 rounded-full mt-2 relative overflow-hidden bg-gray-200 border border-current">
                                        <div class="absolute top-0 left-0 h-full w-full bg-gradient-to-r from-blue-200 to-blue-800"></div>
                                        <div id="humidity-marker" class="absolute top-0 h-full w-1 bg-white border-x border-black z-10 transition-all duration-500" style="left: 0%"></div>
                                    </div>
                                </div>
                            </div>

                            <!-- UV Index -->
                            <div class="weather-card interactive p-6 flex flex-col justify-between h-48" onclick="showDetail('UV INDEX', els.uv.innerText, 'Max daily UV index.', 'wi wi-day-sunny')">
                                <div class="flex justify-between items-start">
                                    <div class="flex flex-col">
                                        <span class="text-sm font-bold opacity-50">UV INDEX</span>
                                        <span id="uv-desc" class="text-xs font-bold text-accent mt-1">--</span>
                                    </div>
                                    <i class="wi wi-day-sunny text-4xl text-accent"></i>
                                </div>
                                <div>
                                    <span class="text-3xl font-bold" id="uv-display">--</span>
                                    <div class="w-full h-3 rounded-full mt-2 relative overflow-hidden bg-gray-200 border border-current">
                                        <div class="absolute top-0 left-0 h-full w-full bg-gradient-to-r from-purple-200 to-purple-900"></div>
                                        <div id="uv-marker" class="absolute top-0 h-full w-1 bg-white border-x border-black z-10 transition-all duration-500" style="left: 0%"></div>
                                    </div>
                                </div>
                            </div>

                            <!-- Visibility -->
                            <div class="weather-card interactive p-6 flex flex-col justify-between h-48" onclick="showDetail('VISIBILITY', els.visibility.innerText + (state.unit === 'f' ? ' mi' : ' km'), 'Visibility distance.', 'wi wi-fog')">
                                <div class="flex justify-between items-start">
                                    <div class="flex flex-col">
                                        <span class="text-sm font-bold opacity-50">VISIBILITY</span>
                                        <span id="vis-desc" class="text-xs font-bold text-accent mt-1">--</span>
                                    </div>
                                    <i class="wi wi-fog text-4xl text-accent"></i>
                                </div>
                                <div>
                                    <span class="text-3xl font-bold"><span id="visibility-display">--</span><span class="text-lg ml-1 unit-dist">km</span></span>
                                    <div class="flex items-end gap-1 h-8 mt-2 justify-between" id="vis-bars">
                                        <div class="w-full bg-blue-200 h-[20%] vis-bar border border-transparent"></div>
                                        <div class="w-full bg-blue-200 h-[40%] vis-bar border border-transparent"></div>
                                        <div class="w-full bg-blue-200 h-[60%] vis-bar border border-transparent"></div>
                                        <div class="w-full bg-blue-200 h-[80%] vis-bar border border-transparent"></div>
                                        <div class="w-full bg-blue-200 h-[100%] vis-bar border border-transparent"></div>
                                    </div>
                                </div>
                            </div>

                            <!-- Precipitation -->
                            <div class="weather-card interactive p-6 flex flex-col justify-between h-48" onclick="showDetail('PRECIPITATION', els.precip.innerText + (state.unit === 'f' ? ' in' : ' mm'), 'Current hourly precipitation.', 'wi wi-raindrop')">
                                <div class="flex justify-between items-start">
                                    <div class="flex flex-col">
                                        <span class="text-sm font-bold opacity-50">PRECIP</span>
                                        <span id="precip-desc" class="text-xs font-bold text-accent mt-1">--</span>
                                    </div>
                                    <i class="wi wi-raindrop text-4xl text-accent"></i>
                                </div>
                                <span class="text-3xl font-bold"><span id="precip-display">--</span><span class="text-lg ml-1 unit-precip">mm</span></span>
                            </div>

                            <!-- Cloud Cover -->
                            <div class="weather-card interactive p-6 flex flex-col justify-between h-48" onclick="showDetail('CLOUD COVER', els.cloud.innerText + '%', 'Sky coverage.', (window.currentCloudIcon || 'wi wi-cloud'))">
                                <div class="flex justify-between items-start">
                                    <div class="flex flex-col">
                                        <span class="text-sm font-bold opacity-50">CLOUDS</span>
                                        <span id="cloud-desc" class="text-xs font-bold text-accent mt-1">--</span>
                                    </div>
                                    <i id="cloud-icon-small" class="wi wi-cloud text-4xl text-accent"></i>
                                </div>
                                <span class="text-3xl font-bold"><span id="cloud-display">--</span><span class="text-lg ml-1">%</span></span>
                            </div>

                            <!-- Pressure -->
                            <div class="weather-card interactive p-6 flex flex-col justify-between h-48" onclick="showDetail('PRESSURE', els.pressure.innerText + ' hPa', 'Atmospheric pressure.', 'wi wi-barometer')">
                                <div class="flex justify-between items-start">
                                    <div class="flex flex-col">
                                        <span class="text-sm font-bold opacity-50">PRESSURE</span>
                                        <span id="press-desc" class="text-xs font-bold text-accent mt-1">--</span>
                                    </div>
                                    <i class="wi wi-barometer text-4xl text-accent"></i>
                                </div>
                                <span class="text-3xl font-bold"><span id="pressure-display">--</span><span class="text-lg ml-1">hPa</span></span>
                            </div>

                            <!-- Sun Times -->
                            <div class="weather-card interactive p-6 flex flex-col justify-between h-48" onclick="showDetail('SUNRISE/SET', els.sunrise.innerText + ' / ' + els.sunset.innerText, 'Sunrise and Sunset times.', 'wi wi-sunrise')">
                                <div class="flex justify-between items-start">
                                    <span class="text-sm font-bold opacity-50">SUN</span>
                                    <i class="wi wi-sunrise text-4xl text-accent"></i>
                                </div>
                                <div class="flex flex-col gap-2 justify-end h-full mt-2">
                                    <div class="flex items-center justify-between">
                                        <span class="text-xs font-bold opacity-50">RISE</span>
                                        <span id="sunrise-display" class="font-bold text-2xl">--:--</span>
                                    </div>
                                    <div class="flex items-center justify-between">
                                        <span class="text-xs font-bold opacity-50">SET</span>
                                        <span id="sunset-display" class="font-bold text-2xl">--:--</span>
                                    </div>
                                </div>
                            </div>

                            <!-- Moon Phase -->
                            <div class="weather-card interactive p-6 flex flex-col justify-between h-48" onclick="showDetail('MOON PHASE', els.moon.innerText, 'Daily moon phase (0=new, 0.5=full).', (window.currentMoonIcon || 'wi wi-moon-full'))">
                                <div class="flex justify-between items-start">
                                    <div class="flex flex-col">
                                        <span class="text-sm font-bold opacity-50">MOON</span>
                                        <span id="moon-desc" class="text-xs font-bold text-accent mt-1">--</span>
                                    </div>
                                    <i id="moon-icon" class="wi wi-moon-full text-4xl text-accent"></i>
                                </div>
                                <div>
                                    <div class="text-xs font-bold opacity-50">PHASE</div>
                                    <div class="text-3xl font-bold" id="moon-phase-display">--</div>
                                </div>
                            </div>
                        </div>

                        <!-- 3 Day Forecast -->
                        <div class="w-full mt-12">
                            <span class="text-sm font-bold opacity-50 mb-6 block">3-DAY FORECAST</span>
                            <div id="forecast-container" class="grid grid-cols-1 md:grid-cols-3 gap-6">
                                <!-- Injected JS as Cards -->
                            </div>
                        </div>

                        <footer class="text-center py-8 opacity-40 text-xs font-mono">
                            DATA: OPEN-METEO API • MONOWEATHER V9.0
                        </footer>

                    </div>
                </div>
            </section>

            <!-- PAGE 1: RADAR -->
            <section class="w-full h-full overflow-y-auto p-6 md:p-12 hidden flex-col items-center">
                <div class="w-full max-w-6xl pb-24 space-y-8">
                    <div class="flex flex-col md:flex-row md:items-end md:justify-between gap-6 border-b-4 border-current pb-6">
                        <div>
                            <h2 class="text-5xl md:text-6xl font-bold tracking-tighter">RADAR_MAP</h2>
                            <p class="opacity-60 font-bold mt-3">UI_READY • MAP_FEED_PENDING</p>
                        </div>
                        <div class="text-right">
                            <div class="text-xs font-bold opacity-60 tracking-widest">TARGET</div>
                            <div id="radar-target" class="text-xl md:text-2xl font-bold uppercase">NO_CITY_SELECTED</div>
                        </div>
                    </div>

                    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                        <!-- LEFT: MAP + LONG TIMELINE -->
                        <div class="lg:col-span-2 space-y-6">
                            <!-- MAP FRAME -->
                            <div class="weather-card p-6" aria-label="Radar map">
                                <div class="flex items-center justify-between">
                                    <div class="text-sm font-bold opacity-50">MAP_FRAME</div>
                                    <div class="text-sm font-bold text-accent">LIVE</div>
                                </div>
                                <div class="mt-4 w-full h-[420px] md:h-[520px] border-4 border-[var(--text-color)] bg-[var(--bg-color)] relative overflow-hidden">
                                    <!-- Leaflet Map (Terminal Engine) -->
                                    <div id="radar-map" class="absolute inset-0 z-0"></div>

                                    <!-- Loading / Error Overlay -->
                                    <div id="radar-overlay" class="absolute inset-0 flex items-center justify-center pointer-events-none z-[100]">
                                        <div class="radar-status-panel text-center px-8 py-8">
                                            <div id="radar-overlay-title" class="text-2xl md:text-3xl font-bold">ACQUIRING_RADAR...</div>
                                            <div id="radar-overlay-sub" class="mt-3 opacity-70">PRECIP_LAYER • RAINVIEWER_FEED</div>
                                            <div class="mt-5 flex justify-center">
                                                <div class="squiggle-wrap">
                                                    <svg class="squiggle-svg" viewBox="0 0 1920 20" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                                                        <g>
                                                            <g transform="translate(0 0)">
                                                                <path d="M0 10 C 15 2, 30 18, 45 10 S 75 2, 90 10 S 120 18, 135 10 S 165 2, 180 10 S 210 18, 225 10 S 240 2, 240 10" stroke="#111" stroke-width="3" stroke-linecap="square" stroke-linejoin="miter" opacity="0.18"/>
                                                                <path d="M0 10 C 15 2, 30 18, 45 10 S 75 2, 90 10 S 120 18, 135 10 S 165 2, 180 10 S 210 18, 225 10 S 240 2, 240 10" stroke="var(--accent-color)" stroke-width="3" stroke-linecap="square" stroke-linejoin="miter" opacity="0.70"/>
                                                            </g>
                                                            <g transform="translate(240 0)">
                                                                <path d="M0 10 C 15 2, 30 18, 45 10 S 75 2, 90 10 S 120 18, 135 10 S 165 2, 180 10 S 210 18, 225 10 S 240 2, 240 10" stroke="#111" stroke-width="3" stroke-linecap="square" stroke-linejoin="miter" opacity="0.18"/>
                                                                <path d="M0 10 C 15 2, 30 18, 45 10 S 75 2, 90 10 S 120 18, 135 10 S 165 2, 180 10 S 210 18, 225 10 S 240 2, 240 10" stroke="var(--accent-color)" stroke-width="3" stroke-linecap="square" stroke-linejoin="miter" opacity="0.70"/>
                                                            </g>
                                                            <g transform="translate(480 0)">
                                                                <path d="M0 10 C 15 2, 30 18, 45 10 S 75 2, 90 10 S 120 18, 135 10 S 165 2, 180 10 S 210 18, 225 10 S 240 2, 240 10" stroke="#111" stroke-width="3" stroke-linecap="square" stroke-linejoin="miter" opacity="0.18"/>
                                                                <path d="M0 10 C 15 2, 30 18, 45 10 S 75 2, 90 10 S 120 18, 135 10 S 165 2, 180 10 S 210 18, 225 10 S 240 2, 240 10" stroke="var(--accent-color)" stroke-width="3" stroke-linecap="square" stroke-linejoin="miter" opacity="0.70"/>
                                                            </g>
                                                            <g transform="translate(720 0)">
                                                                <path d="M0 10 C 15 2, 30 18, 45 10 S 75 2, 90 10 S 120 18, 135 10 S 165 2, 180 10 S 210 18, 225 10 S 240 2, 240 10" stroke="#111" stroke-width="3" stroke-linecap="square" stroke-linejoin="miter" opacity="0.18"/>
                                                                <path d="M0 10 C 15 2, 30 18, 45 10 S 75 2, 90 10 S 120 18, 135 10 S 165 2, 180 10 S 210 18, 225 10 S 240 2, 240 10" stroke="var(--accent-color)" stroke-width="3" stroke-linecap="square" stroke-linejoin="miter" opacity="0.70"/>
                                                            </g>
                                                            <g transform="translate(960 0)">
                                                                <path d="M0 10 C 15 2, 30 18, 45 10 S 75 2, 90 10 S 120 18, 135 10 S 165 2, 180 10 S 210 18, 225 10 S 240 2, 240 10" stroke="#111" stroke-width="3" stroke-linecap="square" stroke-linejoin="miter" opacity="0.18"/>
                                                                <path d="M0 10 C 15 2, 30 18, 45 10 S 75 2, 90 10 S 120 18, 135 10 S 165 2, 180 10 S 210 18, 225 10 S 240 2, 240 10" stroke="var(--accent-color)" stroke-width="3" stroke-linecap="square" stroke-linejoin="miter" opacity="0.70"/>
                                                            </g>
                                                            <g transform="translate(1200 0)">
                                                                <path d="M0 10 C 15 2, 30 18, 45 10 S 75 2, 90 10 S 120 18, 135 10 S 165 2, 180 10 S 210 18, 225 10 S 240 2, 240 10" stroke="#111" stroke-width="3" stroke-linecap="square" stroke-linejoin="miter" opacity="0.18"/>
                                                                <path d="M0 10 C 15 2, 30 18, 45 10 S 75 2, 90 10 S 120 18, 135 10 S 165 2, 180 10 S 210 18, 225 10 S 240 2, 240 10" stroke="var(--accent-color)" stroke-width="3" stroke-linecap="square" stroke-linejoin="miter" opacity="0.70"/>
                                                            </g>
                                                            <g transform="translate(1440 0)">
                                                                <path d="M0 10 C 15 2, 30 18, 45 10 S 75 2, 90 10 S 120 18, 135 10 S 165 2, 180 10 S 210 18, 225 10 S 240 2, 240 10" stroke="#111" stroke-width="3" stroke-linecap="square" stroke-linejoin="miter" opacity="0.18"/>
                                                                <path d="M0 10 C 15 2, 30 18, 45 10 S 75 2, 90 10 S 120 18, 135 10 S 165 2, 180 10 S 210 18, 225 10 S 240 2, 240 10" stroke="var(--accent-color)" stroke-width="3" stroke-linecap="square" stroke-linejoin="miter" opacity="0.70"/>
                                                            </g>
                                                            <g transform="translate(1680 0)">
                                                                <path d="M0 10 C 15 2, 30 18, 45 10 S 75 2, 90 10 S 120 18, 135 10 S 165 2, 180 10 S 210 18, 225 10 S 240 2, 240 10" stroke="#111" stroke-width="3" stroke-linecap="square" stroke-linejoin="miter" opacity="0.18"/>
                                                                <path d="M0 10 C 15 2, 30 18, 45 10 S 75 2, 90 10 S 120 18, 135 10 S 165 2, 180 10 S 210 18, 225 10 S 240 2, 240 10" stroke="var(--accent-color)" stroke-width="3" stroke-linecap="square" stroke-linejoin="miter" opacity="0.70"/>
                                                            </g>
                                                        </g>
                                                    </svg>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Corner Readouts -->
                                    <div class="absolute bottom-3 left-3 text-xs font-bold opacity-80 bg-[var(--card-bg)] px-2 py-1 border-2 border-[var(--text-color)] z-[120]">
                                        LAT: <span id="radar-lat">--</span> • LON: <span id="radar-lon">--</span>
                                    </div>
                                    <div class="absolute bottom-3 right-3 text-xs font-bold opacity-80 bg-[var(--card-bg)] px-2 py-1 border-2 border-[var(--text-color)] text-right z-[120]">
                                        ZOOM: <span id="radar-zoom">--</span><br>
                                        FRAME: <span id="radar-frame-time">--:--</span>
                                    </div>
                                </div>
                            </div>

                            <!-- TIMELINE (RAINVIEWER RANGE) -->
                            <div class="weather-card p-6">
                                <div class="flex items-center justify-between">
                                    <div class="text-sm font-bold opacity-50">TIMELINE</div>
                                    <div class="text-xs font-bold text-accent" id="radar-timeline-mode">RAINVIEWER_RANGE</div>
                                </div>
                                <div class="mt-4 border-4 border-[var(--text-color)] p-4">
                                    <div class="flex items-center justify-between text-xs font-bold opacity-60">
                                        <span>OLDEST</span><span>NOW</span><span>LATEST</span>
                                    </div>

                                    <div class="mt-4">
                                        <div class="flex items-center gap-3">
                                            <button id="radar-play-toggle" class="h-12 w-14 flex items-center justify-center border-4 border-[var(--text-color)] bg-[var(--card-bg)] font-bold" aria-label="Toggle playback">
                                                <span id="radar-play-icon" class="inline-flex items-center justify-center"></span>
                                            </button>
                                            <input id="radar-frame-slider" type="range" min="0" max="0" value="0" step="1" class="flex-1 accent-[var(--accent-color)]">
                                        </div>
                                        <div class="mt-3 flex items-center justify-between">
                                            <div class="text-xs font-bold opacity-60">SELECTED_TIME</div>
                                            <div id="radar-frame-label" class="text-xs font-bold text-accent">--:--</div>
                                        </div>
                                    </div>

                                    <div class="mt-3 text-xs font-bold opacity-60">RAINVIEWER_RANGE • RADAR_AVAILABILITY_VARIES</div>
                                </div>
                            </div>
                        </div>

                        <!-- RIGHT: CONTROLS -->
                        <div class="flex flex-col gap-6">
                            <div class="weather-card p-6">
                                <div class="flex items-center justify-between">
                                    <div class="text-sm font-bold opacity-50">LAYERS</div>
                                    <div class="text-xs font-bold opacity-60">SELECT</div>
                                </div>


                                <!-- Layers -->
                                <div class="mt-6">
                                    <div class="text-xs font-bold opacity-60 mb-2 tracking-widest">OVERLAY</div>
                                    <div class="grid grid-cols-1 gap-3">
                                        <button id="radar-layer-precip" class="py-3 border-4 border-[var(--text-color)] font-bold transition-colors">PRECIP</button>
                                        <button id="radar-layer-temp" class="py-3 border-4 border-[var(--text-color)] font-bold transition-colors">TEMP</button>
                                    </div>
                                    <div class="mt-4 text-xs opacity-60 leading-relaxed">
                                        PRECIP = RAINVIEWER RADAR<br>
                                        TEMP = OPEN‑METEO GRID (BETA)
                                    </div>
                                </div>
                            </div>

                            <div class="weather-card p-6">
                                <div class="flex items-center justify-between">
                                    <div class="text-sm font-bold opacity-50">LEGEND</div>
                                    <div class="text-xs font-bold opacity-60">PRESET</div>
                                </div>
                                <div class="mt-4 space-y-4">
                                    <div>
                                        <div class="text-xs font-bold opacity-60 mb-2">PRECIP_INTENSITY</div>
                                        <div class="h-3 w-full border-2 border-[var(--text-color)] bg-gradient-to-r from-sky-200 via-blue-500 to-purple-700"></div>
                                    </div>
                                    <div>
                                        <div class="text-xs font-bold opacity-60 mb-2">TEMP_SCALE</div>
                                        <div class="h-3 w-full border-2 border-[var(--text-color)]" style="background: linear-gradient(90deg, #7dd3fc 0%, #4ade80 25%, #fde047 50%, #fb923c 75%, #ef4444 100%);"></div>
                                        <div class="mt-2 text-[0.7rem] opacity-60">GRID_SAMPLE • ADAPTIVE_RES • NOT_TILES</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="text-center opacity-60 text-xs font-bold mt-6">
                        MAP DATA © OPENSTREETMAP CONTRIBUTORS • RADAR © RAINVIEWER
                    </div>
                </div>
            </section>

            <!-- PAGE 2: SETTINGS -->
            <section class="w-full h-full overflow-y-auto p-12 hidden flex-col items-center">
                <div class="w-full max-w-3xl space-y-12 pb-24">
                    <h2 class="text-5xl font-bold border-b-4 border-current pb-4 mb-8">SYSTEM_CONFIG</h2>
                    
                    <!-- Theme -->
                    <div>
                        <h3 class="font-bold text-2xl mb-6 flex items-center gap-4"><i class="ti ti-sun"></i> INTERFACE THEME</h3>
                        <div class="flex gap-4">
                            <button id="theme-light" class="flex-1 py-6 border-4 font-bold text-xl transition-colors">LIGHT</button>
                            <button id="theme-dark" class="flex-1 py-6 border-4 font-bold text-xl transition-colors">DARK</button>
                        </div>
                    </div>

                    <!-- Unit -->
                    <div>
                        <h3 class="font-bold text-2xl mb-6 flex items-center gap-4"><i class="ti ti-ruler"></i> MEASUREMENT SYSTEM</h3>
                        <div class="flex gap-4">
                            <button id="unit-c" class="flex-1 py-6 border-4 font-bold text-xl transition-colors">METRIC (°C)</button>
                            <button id="unit-f" class="flex-1 py-6 border-4 font-bold text-xl transition-colors">IMPERIAL (°F)</button>
                        </div>
                    </div>
                    
                    <!-- Time Format -->
                    <div>
                        <h3 class="font-bold text-2xl mb-6 flex items-center gap-4"><i class="ti ti-clock"></i> TIME FORMAT</h3>
                        <div class="flex gap-4">
                            <button id="time-24" class="flex-1 py-6 border-4 font-bold text-xl transition-colors">24 HOUR</button>
                            <button id="time-12" class="flex-1 py-6 border-4 font-bold text-xl transition-colors">12 HOUR</button>
                        </div>
                    </div>

                    <!-- Wind Speed Unit -->
                    <div>
                        <h3 class="font-bold text-2xl mb-6 flex items-center gap-4"><i class="ti ti-wind"></i> WIND SPEED UNIT</h3>
                        <div class="flex gap-4">
                            <button id="wind-kmh" class="flex-1 py-6 border-4 font-bold text-xl transition-colors">KM/H</button>
                            <button id="wind-mph" class="flex-1 py-6 border-4 font-bold text-xl transition-colors">MPH</button>
                        </div>
                    </div>

                    <!-- Accent -->
                    <div>
                        <h3 class="font-bold text-2xl mb-6 flex items-center gap-4"><i class="ti ti-palette"></i> ACCENT HUE</h3>
                        <div class="grid grid-cols-5 gap-6" id="color-picker">
                            <button data-color="#f97316" class="aspect-square bg-orange-500 border-4 border-transparent hover:scale-105 transition-transform shadow-lg"></button>
                            <button data-color="#3b82f6" class="aspect-square bg-blue-500 border-4 border-transparent hover:scale-105 transition-transform shadow-lg"></button>
                            <button data-color="#22c55e" class="aspect-square bg-green-500 border-4 border-transparent hover:scale-105 transition-transform shadow-lg"></button>
                            <button data-color="#a855f7" class="aspect-square bg-purple-500 border-4 border-transparent hover:scale-105 transition-transform shadow-lg"></button>
                            <button data-color="#ef4444" class="aspect-square bg-red-500 border-4 border-transparent hover:scale-105 transition-transform shadow-lg"></button>
                        </div>
                    </div>
                </div>
            </section>

            <!-- PAGE 3: INFO -->
            <section class="w-full h-full overflow-y-auto p-6 md:p-12 hidden flex-col items-center">
                <div class="w-full max-w-4xl pb-24 space-y-10">
                    <div class="text-center">
                        <i class="ti ti-info-circle text-7xl md:text-8xl text-accent mb-6 block"></i>
                        <h1 class="text-5xl md:text-6xl font-bold tracking-tighter">MONO_WEATHER</h1>
                        <p class="mt-4 text-lg md:text-xl opacity-70 font-bold">A minimalist atmospheric monitoring terminal.</p>
                        <div class="h-1 w-32 bg-accent mx-auto mt-8"></div>
                    </div>

                    <div class="weather-card p-6 md:p-8">
                        <div class="text-sm font-bold opacity-50 mb-4 tracking-widest">DATA_SOURCES</div>
                        <div class="space-y-3 text-sm md:text-base leading-relaxed">
                            <div>
                                <span class="font-bold">OPEN‑METEO</span> (weather + geocoding)
                                <div class="opacity-70">https://open-meteo.com/ • https://open-meteo.com/en/docs</div>
                            </div>
                            <div>
                                <span class="font-bold">RAINVIEWER</span> (radar frames + tiles)
                                <div class="opacity-70">https://www.rainviewer.com/api.html</div>
                            </div>
                        </div>
                    </div>

                    <div class="weather-card p-6 md:p-8">
                        <div class="text-sm font-bold opacity-50 mb-4 tracking-widest">MAP_ATTRIBUTION</div>
                        <div class="space-y-3 text-sm md:text-base leading-relaxed">
                            <div>
                                <span class="font-bold">BASE MAP (LIGHT):</span> © OpenStreetMap contributors
                                <div class="opacity-70">https://www.openstreetmap.org/copyright</div>
                            </div>
                            <div>
                                <span class="font-bold">BASE MAP (DARK):</span> © OpenStreetMap contributors © CARTO
                                <div class="opacity-70">https://carto.com/attributions</div>
                            </div>
                            <div>
                                <span class="font-bold">RADAR OVERLAY:</span> © RainViewer
                            </div>
                        </div>
                    </div>

                    <div class="weather-card p-6 md:p-8">
                        <div class="text-sm font-bold opacity-50 mb-4 tracking-widest">LIBRARIES_&_ASSETS</div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 text-sm md:text-base leading-relaxed">
                            <div>
                                <div class="font-bold">LEAFLET</div>
                                <div class="opacity-70">Interactive maps • https://leafletjs.com</div>
                            </div>
                            <div>
                                <div class="font-bold">TAILWIND CSS (CDN)</div>
                                <div class="opacity-70">UI utility classes • https://tailwindcss.com</div>
                            </div>
                            <div>
                                <div class="font-bold">WEATHER ICONS</div>
                                <div class="opacity-70">Erik Flowers • https://erikflowers.github.io/weather-icons/</div>
                            </div>
                            <div>
                                <div class="font-bold">TABLER ICONS (WEBFONT)</div>
                                <div class="opacity-70">https://tabler.io/icons</div>
                            </div>
                            <div>
                                <div class="font-bold">SPACE MONO</div>
                                <div class="opacity-70">Google Fonts • https://fonts.google.com/specimen/Space+Mono</div>
                            </div>
                        </div>
                    </div>

                    <div class="weather-card p-6 md:p-8">
                        <div class="text-sm font-bold opacity-50 mb-4 tracking-widest">AI_DISCLOSURE</div>
                        <div class="text-sm md:text-base leading-relaxed opacity-80">
                            This project may include code and UI decisions assisted by an AI system.
                            Outputs from AI-assisted software can be incomplete or incorrect.
                            Always verify critical information.
                        </div>
                    </div>

                    <div class="weather-card p-6 md:p-8">
                        <div class="text-sm font-bold opacity-50 mb-4 tracking-widest">PRIVACY</div>
                        <div class="text-sm md:text-base leading-relaxed opacity-80">
                            MonoWeather stores your settings and last selected city locally (cookies + localStorage) for convenience.
                            No analytics or third-party tracking is intentionally added by this project.
                        </div>
                    </div>

                    <div class="text-center opacity-60 text-xs font-bold">
                        MONOWEATHER UI • DATA: OPEN‑METEO • RADAR: RAINVIEWER
                    </div>
                </div>
            </section>

        </div>
    </main>

    <!-- Details Modal -->
    <dialog id="detail-modal" class="outline-none rounded-none backdrop:bg-black/50">
        <div class="p-8 relative flex flex-col items-center text-center bg-[var(--card-bg)] text-[var(--text-color)] border-4 border-[var(--text-color)]">
            <button onclick="window.closeModal()" class="absolute top-4 right-4 h-12 w-12 flex items-center justify-center bg-accent text-white rounded-full hover:scale-110 transition-transform shadow-lg border-2 border-transparent">
                 <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="3">
                    <path stroke-linecap="square" stroke-linejoin="miter" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
            <h3 id="modal-title" class="text-2xl font-bold opacity-50 mb-4 tracking-widest mt-4">TITLE</h3>
            <div id="modal-icon-container" class="mb-6"></div>
            <p id="modal-value" class="text-5xl md:text-6xl font-bold text-accent mb-6 break-words max-w-full">VALUE</p>
            <p id="modal-desc" class="text-lg leading-relaxed max-w-sm">Description goes here.</p>
            <div id="modal-extra" class="w-full mt-8"></div>
        </div>
    </dialog>

    <script>
        // --- Cookies + Storage (settings + city persistence) ---
        function setCookie(name, value, days) {
            try {
                var maxAge = (days ? (days * 24 * 60 * 60) : (365 * 24 * 60 * 60));
                document.cookie = `${encodeURIComponent(name)}=${encodeURIComponent(String(value))}; Max-Age=${maxAge}; Path=/; SameSite=Lax`;
            } catch (e) {}
        }
        function getCookie(name) {
            try {
                var key = encodeURIComponent(name) + '=';
                var parts = document.cookie.split(';');
                for (var i = 0; i < parts.length; i++) {
                    var c = parts[i].trim();
                    if (c.indexOf(key) === 0) return decodeURIComponent(c.substring(key.length));
                }
            } catch (e) {}
            return null;
        }
        function hasCookie(name) {
            var v = getCookie(name);
            return v !== null && v !== undefined && v !== '';
        }
        function readStore(key, fallback) {
            var c = getCookie(key);
            if (c !== null && c !== undefined && c !== '') return c;
            try {
                var ls = localStorage.getItem(key);
                if (ls !== null && ls !== undefined && ls !== '') return ls;
            } catch (e) {}
            return fallback;
        }
        function persistStore(key, value, days) {
            try { localStorage.setItem(key, value); } catch (e) {}
            setCookie(key, value, days || 365);
        }

        // --- Globals ---
        var initialUnit = readStore('mw_unit', 'c');
        var initialWindUnit = readStore('mw_wind_unit', (initialUnit === 'f' ? 'mph' : 'kmh'));

        var state = {
            page: 0,
            unit: initialUnit,
            // Wind speed is independent from temperature units
            windSpeedUnit: initialWindUnit,
            timeFormat: readStore('mw_time', '24'),
            theme: readStore('mw_theme', 'light'),
            accent: readStore('mw_accent', '#f97316'),
            weatherData: null,
            cityData: null,

            // Radar state
            radar: {
                map: null,
                base: null,
                // Precip radar tile layers (double-buffered to avoid flashing)
                rainviewer: null,
                rainviewerPending: null,
                rainviewerPath: null,
                frames: [],
                frameIndex: 0,

                // Timeline minute-scrub state (minute-by-minute across RainViewer's available range)
                minTimeSec: null,
                maxTimeSec: null,
                selectedTimeSec: null,

                playing: false,
                timer: null,
                precipEnabled: true,
                lastCenter: null,
                inited: false,
                marker: null,

                // Temperature layer (Open-Meteo sampled grid)
                tempEnabled: false,
                tempLayer: null,
                tempLayerPending: null,
                tempBusy: false,
                tempTimer: null,
                tempLastBoundsKey: null,

                // Timeline-aware temperature cache (hourly series per sample point)
                tempSeriesCache: null
            }
        };

        var pagesConfig = [
            // Weather icon is dynamic (updates to current condition after a city is selected)
            { icon: 'wi wi-day-sunny', label: 'WEATHER' },
            // Use Tabler Icons for mobile slider icons (desktop hides glyphs)
            { icon: 'ti ti-radar', label: 'RADAR' },
            { icon: 'ti ti-settings', label: 'SETTINGS' },
            { icon: 'ti ti-info-circle', label: 'INFO' }
        ];

        var weatherCodeMap = {
            0: { desc: 'Clear Sky', icon: 'wi wi-day-sunny' },
            1: { desc: 'Mainly Clear', icon: 'wi wi-day-sunny' },
            2: { desc: 'Partly Cloudy', icon: 'wi wi-day-cloudy' },
            3: { desc: 'Overcast', icon: 'wi wi-cloudy' },
            45: { desc: 'Fog', icon: 'wi wi-fog' },
            48: { desc: 'Rime Fog', icon: 'wi wi-fog' },
            51: { desc: 'Light Drizzle', icon: 'wi wi-sprinkle' },
            53: { desc: 'Drizzle', icon: 'wi wi-sprinkle' },
            55: { desc: 'Heavy Drizzle', icon: 'wi wi-rain-mix' },
            56: { desc: 'Freezing Drizzle', icon: 'wi wi-rain-mix' },
            57: { desc: 'Heavy Freezing Drizzle', icon: 'wi wi-rain-mix' },
            61: { desc: 'Slight Rain', icon: 'wi wi-showers' },
            63: { desc: 'Rain', icon: 'wi wi-rain' },
            65: { desc: 'Heavy Rain', icon: 'wi wi-rain' },
            66: { desc: 'Freezing Rain', icon: 'wi wi-rain-mix' },
            67: { desc: 'Heavy Freezing Rain', icon: 'wi wi-rain-mix' },
            71: { desc: 'Slight Snow', icon: 'wi wi-snow' },
            73: { desc: 'Snow', icon: 'wi wi-snow' },
            75: { desc: 'Heavy Snow', icon: 'wi wi-snow' },
            77: { desc: 'Snow Grains', icon: 'wi wi-snow' },
            80: { desc: 'Showers', icon: 'wi wi-showers' },
            81: { desc: 'Heavy Showers', icon: 'wi wi-rain-wind' },
            82: { desc: 'Violent Showers', icon: 'wi wi-rain-wind' },
            85: { desc: 'Snow Showers', icon: 'wi wi-snow' },
            86: { desc: 'Heavy Snow Showers', icon: 'wi wi-snow' },
            95: { desc: 'Thunderstorm', icon: 'wi wi-thunderstorm' },
            96: { desc: 'Thunderstorm Hail', icon: 'wi wi-storm-showers' },
            99: { desc: 'Heavy Thunderstorm', icon: 'wi wi-storm-showers' }
        };

        var imperialCountries = ['US', 'MM', 'LR'];

        // --- Local moon phase (no external API) ---
        function computeMoonPhase(date) {
            var synodic = 29.530588853; // days
            var ref = Date.UTC(2000, 0, 6, 18, 14, 0); // known new moon reference
            var daysSince = (date.getTime() - ref) / 86400000;
            var lunations = daysSince / synodic;
            var frac = lunations - Math.floor(lunations);
            // Illuminated fraction (0 new, 1 full)
            var illum = 0.5 * (1 - Math.cos(2 * Math.PI * frac));
            var pctIllum = Math.round(illum * 100);
            // Map to common names
            var name = 'WAXING CRESCENT';
            if (frac < 0.03 || frac > 0.97) name = 'NEW MOON';
            else if (frac < 0.22) name = 'WAXING CRESCENT';
            else if (frac < 0.28) name = 'FIRST QUARTER';
            else if (frac < 0.47) name = 'WAXING GIBBOUS';
            else if (frac < 0.53) name = 'FULL MOON';
            else if (frac < 0.72) name = 'WANING GIBBOUS';
            else if (frac < 0.78) name = 'LAST QUARTER';
            else name = 'WANING CRESCENT';
            return { fraction: frac, name: name, percent: pctIllum, illumination: pctIllum };
        }
        
        var usStateAbbreviations = {
            'Alabama': 'AL', 'Alaska': 'AK', 'Arizona': 'AZ', 'Arkansas': 'AR', 'California': 'CA',
            'Colorado': 'CO', 'Connecticut': 'CT', 'Delaware': 'DE', 'Florida': 'FL', 'Georgia': 'GA',
            'Hawaii': 'HI', 'Idaho': 'ID', 'Illinois': 'IL', 'Indiana': 'IN', 'Iowa': 'IA',
            'Kansas': 'KS', 'Kentucky': 'KY', 'Louisiana': 'LA', 'Maine': 'ME', 'Maryland': 'MD',
            'Massachusetts': 'MA', 'Michigan': 'MI', 'Minnesota': 'MN', 'Mississippi': 'MS', 'Missouri': 'MO',
            'Montana': 'MT', 'Nebraska': 'NE', 'Nevada': 'NV', 'New Hampshire': 'NH', 'New Jersey': 'NJ',
            'New Mexico': 'NM', 'New York': 'NY', 'North Carolina': 'NC', 'North Dakota': 'ND', 'Ohio': 'OH',
            'Oklahoma': 'OK', 'Oregon': 'OR', 'Pennsylvania': 'PA', 'Rhode Island': 'RI', 'South Carolina': 'SC',
            'South Dakota': 'SD', 'Tennessee': 'TN', 'Texas': 'TX', 'Utah': 'UT', 'Vermont': 'VT',
            'Virginia': 'VA', 'Washington': 'WA', 'West Virginia': 'WV', 'Wisconsin': 'WI', 'Wyoming': 'WY',
            'District of Columbia': 'DC', 'Puerto Rico': 'PR', 'Guam': 'GU', 'American Samoa': 'AS',
            'U.S. Virgin Islands': 'VI', 'Northern Mariana Islands': 'MP'
        };
        
        var els = {};

        // --- Init ---
        function init() {
            // Map elements
            els.body = document.body;
            els.pages = document.querySelectorAll('#page-container > section');
            els.slider = document.getElementById('nav-slider');
            els.handle = document.getElementById('slider-handle');
            els.handleIcon = document.getElementById('handle-icon');
            els.handleText = document.getElementById('handle-text');
            els.ticksContainer = document.getElementById('ticks-container');
            
            els.search = document.getElementById('city-search');
            els.searchBtn = document.getElementById('search-btn');
            els.dropdown = document.getElementById('search-dropdown');
            els.loading = document.getElementById('loading-state');
            els.content = document.getElementById('weather-content');
            els.error = document.getElementById('error-msg');
            
            // Displays
            els.city = document.getElementById('city-display');
            els.date = document.getElementById('date-display');
            els.desc = document.getElementById('desc-display');
            els.temp = document.getElementById('temp-display');
            els.high = document.getElementById('high-display');
            els.low = document.getElementById('low-display');
            els.unit = document.getElementById('unit-display');
            els.icon = document.getElementById('main-icon');

            // New homepage boxes
            els.feels = document.getElementById('feelslike-display');
            els.tempDescBox = document.getElementById('temp-desc');
            els.moon = document.getElementById('moon-phase-display');
            els.moonDesc = document.getElementById('moon-desc');
            els.moonIcon = document.getElementById('moon-icon');
            
            els.wind = document.getElementById('wind-display');
            els.windDesc = document.getElementById('wind-desc');
            els.windCompass = document.getElementById('wind-compass');
            
            els.humidity = document.getElementById('humidity-display');
            els.humidityDesc = document.getElementById('hum-desc');
            els.humidityMarker = document.getElementById('humidity-marker');
            
            els.uv = document.getElementById('uv-display');
            els.uvDesc = document.getElementById('uv-desc');
            els.uvMarker = document.getElementById('uv-marker');
            
            els.pressure = document.getElementById('pressure-display');
            els.pressDesc = document.getElementById('press-desc');
            
            els.visibility = document.getElementById('visibility-display');
            els.visDesc = document.getElementById('vis-desc');
            els.visBars = document.getElementById('vis-bars');
            
            els.cloud = document.getElementById('cloud-display');
            els.cloudDesc = document.getElementById('cloud-desc');
            els.cloudIconSmall = document.getElementById('cloud-icon-small');
            
            els.precip = document.getElementById('precip-display');
            els.precipDesc = document.getElementById('precip-desc');
            
            els.sunrise = document.getElementById('sunrise-display');
            els.sunset = document.getElementById('sunset-display');
            els.forecast = document.getElementById('forecast-container');
            els.radarTarget = document.getElementById('radar-target');

            // Radar
            els.radarMap = document.getElementById('radar-map');
            els.radarOverlay = document.getElementById('radar-overlay');
            els.radarOverlayTitle = document.getElementById('radar-overlay-title');
            els.radarOverlaySub = document.getElementById('radar-overlay-sub');
            els.radarLat = document.getElementById('radar-lat');
            els.radarLon = document.getElementById('radar-lon');
            els.radarZoom = document.getElementById('radar-zoom');
            els.radarFrameTime = document.getElementById('radar-frame-time');
            els.radarLayerPrecip = document.getElementById('radar-layer-precip');
            els.radarLayerTemp = document.getElementById('radar-layer-temp');

            els.radarFrameSlider = document.getElementById('radar-frame-slider');
            els.radarFrameLabel = document.getElementById('radar-frame-label');
            els.radarPlayToggle = document.getElementById('radar-play-toggle');
            els.radarPlayIcon = document.getElementById('radar-play-icon');
            els.radarTimelineMode = document.getElementById('radar-timeline-mode');

            // Settings
            els.themeLight = document.getElementById('theme-light');
            els.themeDark = document.getElementById('theme-dark');
            els.unitC = document.getElementById('unit-c');
            els.unitF = document.getElementById('unit-f');
            els.time24 = document.getElementById('time-24');
            els.time12 = document.getElementById('time-12');
            els.windKmh = document.getElementById('wind-kmh');
            els.windMph = document.getElementById('wind-mph');
            els.colorPicker = document.getElementById('color-picker');

            // Modal
            els.modal = document.getElementById('detail-modal');
            els.modalTitle = document.getElementById('modal-title');
            els.modalValue = document.getElementById('modal-value');
            els.modalDesc = document.getElementById('modal-desc');
            els.modalIcon = document.getElementById('modal-icon-container');
            els.modalExtra = document.getElementById('modal-extra');

            window.els = els; // Ensure global access for onclick handlers

            setupSlider();
            applySettings();
            setupEvents();
            setPage(0);
            
            // Modal Backdrop Click
            els.modal.addEventListener('click', function(event) {
                var rect = els.modal.getBoundingClientRect();
                var isInDialog = (rect.top <= event.clientY && event.clientY <= rect.top + rect.height &&
                  rect.left <= event.clientX && event.clientX <= rect.left + rect.width);
                if (!isInDialog) {
                    els.modal.close();
                }
            });

            // Restore last city (from cookie/localStorage)
            try {
                var raw = readStore('mw_last_city', null);
                if (raw) {
                    var c = JSON.parse(raw);
                    if (c && c.latitude !== undefined && c.longitude !== undefined && c.name) {
                        // Populate search box for UI continuity
                        els.search.value = c.name;
                        // Load immediately
                        handleSearchWithCoords(c);
                    }
                }
            } catch (e) {}

            els.search.focus();

            // Fix slider handle position when switching between mobile/desktop
            try {
                var resizeTimer;
                window.addEventListener('resize', function(){
                    clearTimeout(resizeTimer);
                    resizeTimer = setTimeout(function(){
                        try { setPage(state.page); } catch (e) {}
                        // If radar map is visible/initialized, Leaflet may need a resize refresh
                        try { if (state.radar && state.radar.inited && state.radar.map) state.radar.map.invalidateSize(); } catch (e) {}
                    }, 120);
                });
            } catch (e) {}
        }

        // --- Navigation / Slider ---
        function applyNavIcon(el, icon, sizeClass, extraClass) {
            if (!el) return;
            var size = sizeClass || 'text-xl';
            var extra = extraClass || '';

            // Weather Icons
            if (icon && icon.indexOf('wi ') === 0) {
                el.className = `${icon} ${size} ${extra}`.trim();
                return;
            }

            // Tabler Icons (webfont) use `ti ti-...`
            if (icon && icon.indexOf('ti ') === 0) {
                el.className = `${icon} ${size} ${extra}`.trim();
                return;
            }

            // Fallback
            el.className = `${size} ${extra}`.trim();
        }

        function updateWeatherNavIcon(iconClass) {
            if (!iconClass) return;
            pagesConfig[0].icon = iconClass;
            if (els.tickIcons && els.tickIcons[0]) {
                applyNavIcon(els.tickIcons[0], iconClass, 'text-xl');
            }
            // If we're currently on the WEATHER page, also update the handle icon immediately.
            if (state.page === 0 && els.handleIcon) {
                applyNavIcon(els.handleIcon, iconClass, 'text-2xl', 'text-[var(--handle-text)]');
            }
        }

        function setupSlider() {
            // Render Ticks
            els.ticksContainer.innerHTML = '';
            els.tickIcons = [];

            pagesConfig.forEach((page, idx) => {
                var tick = document.createElement('div');
                tick.className = 'tick-hitbox group/tick mb-8 last:mb-0';
                tick.onclick = () => setPage(idx);
                tick.title = page.label;

                tick.innerHTML = `
                    <div class="tick-icon-box">
                        <div class="tick-icon">
                            <i class="nav-icon"></i>
                        </div>
                    </div>
                    <span class="nav-label">${page.label}</span>
                `;

                els.ticksContainer.appendChild(tick);
                var iconEl = tick.querySelector('i.nav-icon');
                els.tickIcons[idx] = iconEl;
                applyNavIcon(iconEl, page.icon, 'text-xl');
            });

            // Ensure WEATHER tick icon reflects current condition if we already have data
            try {
                if (state.weatherData && state.weatherData.current_weather) {
                    var wi = weatherCodeMap[state.weatherData.current_weather.weathercode];
                    if (wi && wi.icon) updateWeatherNavIcon(wi.icon);
                }
            } catch (e) {}

            setupDrag();
        }
        
        var isDragging = false;
        var startY = 0;
        var startTop = 0;
        var startX = 0;
        var startLeft = 0;

        function isMobileNav() {
            return window.matchMedia && window.matchMedia('(max-width: 767px)').matches;
        }
        
        function setupDrag() {
            els.handle.addEventListener('mousedown', (e) => {
                isDragging = true;
                startY = e.clientY;
                startTop = els.handle.offsetTop;
                startX = e.clientX;
                startLeft = els.handle.offsetLeft;
                els.handle.classList.add('dragging');
                document.addEventListener('mousemove', onDrag);
                document.addEventListener('mouseup', stopDrag);
                e.preventDefault();
            });

            // Touch support
            els.handle.addEventListener('touchstart', (e) => {
                var t = e.touches && e.touches[0];
                if (!t) return;
                isDragging = true;
                startY = t.clientY;
                startTop = els.handle.offsetTop;
                startX = t.clientX;
                startLeft = els.handle.offsetLeft;
                els.handle.classList.add('dragging');
                document.addEventListener('touchmove', onDragTouch, { passive: false });
                document.addEventListener('touchend', stopDragTouch);
                e.preventDefault();
            }, { passive: false });
        }

        function onDragTouch(e) {
            var t = e.touches && e.touches[0];
            if (!t) return;
            onDrag({ clientX: t.clientX, clientY: t.clientY, preventDefault: function(){} });
            e.preventDefault();
        }

        function stopDragTouch(e) {
            stopDrag(e);
            document.removeEventListener('touchmove', onDragTouch);
            document.removeEventListener('touchend', stopDragTouch);
        }

        function onDrag(e) {
            if (!isDragging) return;

            var ticks = els.ticksContainer.children;
            if (!ticks || ticks.length === 0) return;

            if (isMobileNav()) {
                // Horizontal drag
                var dx = e.clientX - startX;
                var newLeft = startLeft + dx;

                var firstTick = ticks[0];
                var lastTick = ticks[ticks.length - 1];
                var containerLeft = els.ticksContainer.offsetLeft;

                var minLeft = containerLeft + firstTick.offsetLeft + (firstTick.clientWidth / 2);
                var maxLeft = containerLeft + lastTick.offsetLeft + (lastTick.clientWidth / 2);

                if (newLeft < minLeft) newLeft = minLeft;
                if (newLeft > maxLeft) newLeft = maxLeft;

                els.handle.style.left = newLeft + 'px';
                els.handle.style.top = '50%';
            } else {
                // Vertical drag
                var dy = e.clientY - startY;
                var newTop = startTop + dy;

                var firstTickV = ticks[0];
                var lastTickV = ticks[ticks.length - 1];
                var containerTop = els.ticksContainer.offsetTop;

                var minTop = containerTop + firstTickV.offsetTop + (firstTickV.clientHeight / 2);
                var maxTop = containerTop + lastTickV.offsetTop + (lastTickV.clientHeight / 2);

                if (newTop < minTop) newTop = minTop;
                if (newTop > maxTop) newTop = maxTop;

                els.handle.style.top = newTop + 'px';
            }
        }

        function stopDrag(e) {
            if (!isDragging) return;
            isDragging = false;
            els.handle.classList.remove('dragging');
            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('mouseup', stopDrag);

            var ticks = Array.from(els.ticksContainer.children);
            if (!ticks.length) return;

            var closestIdx = 0;
            var minDiff = Infinity;

            if (isMobileNav()) {
                var currentLeft = els.handle.offsetLeft;
                var containerLeft = els.ticksContainer.offsetLeft;

                ticks.forEach((tick, idx) => {
                    var center = containerLeft + tick.offsetLeft + (tick.clientWidth / 2);
                    var diff = Math.abs(center - currentLeft);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestIdx = idx;
                    }
                });
            } else {
                var currentTop = els.handle.offsetTop;
                var containerTop = els.ticksContainer.offsetTop;

                ticks.forEach((tick, idx) => {
                    var center = containerTop + tick.offsetTop + (tick.clientHeight / 2);
                    var diff = Math.abs(center - currentTop);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestIdx = idx;
                    }
                });
            }

            setPage(closestIdx);
        }

        function setPage(index) {
            state.page = index;
            
            // Get target position
            var ticks = els.ticksContainer.children;
            if (ticks[index]) {
                if (window.matchMedia && window.matchMedia('(max-width: 767px)').matches) {
                    // Mobile: position handle horizontally by tick center
                    var containerLeft = els.ticksContainer.offsetLeft;
                    var centerX = containerLeft + ticks[index].offsetLeft + (ticks[index].clientWidth / 2);
                    els.handle.style.left = centerX + 'px';
                    els.handle.style.top = '50%';
                } else {
                    // Desktop: clear any mobile inline left so CSS can pin it to the rail
                    els.handle.style.left = '';
                    var containerTop = els.ticksContainer.offsetTop;
                    var center = containerTop + ticks[index].offsetTop + (ticks[index].clientHeight / 2);
                    els.handle.style.top = center + 'px';
                }
            }
            
            // Update Handle Icon (supports weather-icons + pixelarticons)
            applyNavIcon(els.handleIcon, pagesConfig[index].icon, 'text-2xl', 'text-[var(--handle-text)]');
            // Keep text updated for accessibility, though it's hidden visually
            els.handleText.innerText = pagesConfig[index].label;
            els.handle.title = pagesConfig[index].label;
            // Mobile tooltip label (disabled visually, but safe to keep)
            try { els.handle.setAttribute('data-label', pagesConfig[index].label); } catch (e) {}

            // Switch Pages
            els.pages.forEach((page, i) => {
                if (i === index) {
                    page.classList.remove('hidden');
                    page.classList.add('flex');
                } else {
                    page.classList.add('hidden');
                    page.classList.remove('flex');
                }
            });

            // Lazy-init radar when first visiting the page
            if (index === 1) {
                requestAnimationFrame(function(){
                    initRadar();
                });
            }
        }
        window.setPage = setPage;

        // --- Radar (Leaflet + RainViewer) ---
        function initRadar() {
            if (!els.radarMap) return;
            if (state.radar.inited) {
                // Leaflet needs a resize invalidation when shown
                try { state.radar.map.invalidateSize(); } catch (e) {}
                return;
            }
            if (typeof L === 'undefined') {
                if (els.radarOverlayTitle) els.radarOverlayTitle.innerText = 'RADAR_INIT_FAILED';
                if (els.radarOverlaySub) els.radarOverlaySub.innerText = 'LEAFLET_NOT_LOADED';
                return;
            }

            state.radar.inited = true;

            // Map init
            state.radar.map = L.map('radar-map', {
                zoomControl: true,
                attributionControl: false
            });

            // Default center: selected city if available, else world
            var lat = (state.cityData && state.cityData.latitude) ? state.cityData.latitude : 20;
            var lon = (state.cityData && state.cityData.longitude) ? state.cityData.longitude : 0;
            var zoom = (state.cityData && state.cityData.latitude) ? 7 : 2;

            state.radar.map.setView([lat, lon], zoom);

            // Add marker if city selected
            if (state.cityData && state.cityData.latitude && state.cityData.longitude) {
                if (state.radar.marker) {
                    try { state.radar.map.removeLayer(state.radar.marker); } catch (e) {}
                }
                state.radar.marker = L.marker([lat, lon]).addTo(state.radar.map);
            }

            // Base map
            // Light theme: OSM standard. Dark theme: CartoDB DarkMatter (no key required).
            function getRadarBaseUrl() {
                return (state.theme === 'dark')
                    ? 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png'
                    : 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
            }

            state.radar.base = L.tileLayer(getRadarBaseUrl(), {
                maxZoom: 18,
                attribution: ''
            }).addTo(state.radar.map);

            // Update readouts (+ temp layer debounce refresh)
            function scheduleTempRefresh() {
                if (!state.radar.tempEnabled) return;
                if (state.radar.tempTimer) clearTimeout(state.radar.tempTimer);
                state.radar.tempTimer = setTimeout(function(){
                    // Don't force refetch on every move/zoom end; only refetch when bounds key changes.
                    updateTempLayer(false);
                }, 450);
            }

            function updateReadouts() {
                if (!state.radar.map) return;
                var c = state.radar.map.getCenter();
                if (els.radarLat) els.radarLat.innerText = c.lat.toFixed(2);
                if (els.radarLon) els.radarLon.innerText = c.lng.toFixed(2);
                if (els.radarZoom) els.radarZoom.innerText = state.radar.map.getZoom();
                scheduleTempRefresh();
            }
            state.radar.map.on('moveend', updateReadouts);
            state.radar.map.on('zoomend', updateReadouts);
            updateReadouts();

            // --- Radar UI: Layers ---
            if (els.radarLayerPrecip) {
                els.radarLayerPrecip.onclick = () => {
                    state.radar.precipEnabled = !state.radar.precipEnabled;
                    syncRadarLayerButtons();
                    updateRadarLayer();
                };
            }

            if (els.radarLayerTemp) {
                els.radarLayerTemp.onclick = () => {
                    state.radar.tempEnabled = !state.radar.tempEnabled;
                    syncRadarLayerButtons();
                    updateTempLayer(true);
                };
            }

            // Initialize layer button states
            syncRadarLayerButtons();

            if (els.radarFrameSlider) {
                // Slider represents RainViewer FRAMES (0..N-1)
                els.radarFrameSlider.oninput = (e) => {
                    var frames = state.radar.frames || [];
                    if (!frames.length) return;

                    var idx = parseInt(e.target.value, 10);
                    if (isNaN(idx)) idx = 0;
                    if (idx < 0) idx = 0;
                    if (idx > frames.length - 1) idx = frames.length - 1;

                    state.radar.frameIndex = idx;
                    state.radar.selectedTimeSec = frames[idx].time;
                    updateRadarLayer();
                };
            }

            if (els.radarPlayToggle) {
                els.radarPlayToggle.onclick = () => {
                    if (state.radar.playing) {
                        stopRadarPlayback();
                    } else {
                        startRadarPlayback();
                    }
                    syncRadarPlaybackButton();
                };
            }

            // Initialize play/pause icon
            syncRadarPlaybackButton();

            // Fetch radar frames
            fetchRainViewerFrames();

            // Ensure temp overlay is applied if enabled
            if (state.radar.tempEnabled) updateTempLayer(true);

        }

        async function fetchRainViewerFrames() {
            try {
                if (els.radarOverlayTitle) els.radarOverlayTitle.innerText = 'ACQUIRING_RADAR...';
                if (els.radarOverlaySub) els.radarOverlaySub.innerText = 'PRECIP_LAYER • RAINVIEWER_FEED';
                if (els.radarOverlay) els.radarOverlay.classList.remove('hidden');

                // RainViewer Weather Maps API (public)
                // Docs: https://www.rainviewer.com/api.html
                var res = await fetch('https://api.rainviewer.com/public/weather-maps.json');
                var data = await res.json();

                // Build a combined timeline: past (and future if available)
                var pastFrames = [];
                var futureFrames = [];
                if (data && data.radar) {
                    if (Array.isArray(data.radar.past)) pastFrames = data.radar.past;
                    if (Array.isArray(data.radar.nowcast)) futureFrames = data.radar.nowcast; // RainViewer future frames
                }

                // Some accounts/regions may not return nowcast; still works with past-only
                // Combine and sort by time ascending
                var frames = pastFrames.concat(futureFrames);
                frames = frames.filter(f => f && f.time && f.path);
                frames.sort((a,b) => a.time - b.time);

                state.radar.frames = frames;

                if (!frames || frames.length === 0) {
                    if (els.radarOverlayTitle) els.radarOverlayTitle.innerText = 'RADAR_UNAVAILABLE';
                    if (els.radarOverlaySub) els.radarOverlaySub.innerText = 'NO_FRAMES_RETURNED';
                    return;
                }

                // Compute actual time range (RainViewer availability)
                var nowSec = Math.floor(Date.now() / 1000);
                var minT = frames[0].time;
                var maxT = frames[frames.length - 1].time;

                state.radar.minTimeSec = minT;
                state.radar.maxTimeSec = maxT;

                // Default selection: nearest frame to "now" (clamped to availability)
                state.radar.selectedTimeSec = Math.max(minT, Math.min(maxT, nowSec));
                state.radar.frameIndex = findNearestRadarFrameIndex(state.radar.selectedTimeSec);
                state.radar.selectedTimeSec = frames[state.radar.frameIndex].time;

                // Configure slider to represent FRAMES (discrete RainViewer steps)
                if (els.radarFrameSlider) {
                    els.radarFrameSlider.min = 0;
                    els.radarFrameSlider.max = Math.max(0, frames.length - 1);
                    els.radarFrameSlider.step = 1;
                    els.radarFrameSlider.value = state.radar.frameIndex;
                }

                // Timeline mode label: show actual coverage returned
                try {
                    if (els.radarTimelineMode) {
                        var hasFuture = (futureFrames && futureFrames.length);
                        var pastH = Math.max(0, (nowSec - minT) / 3600);
                        var futH = Math.max(0, (maxT - nowSec) / 3600);
                        els.radarTimelineMode.innerText = hasFuture
                            ? `RAINVIEWER • PAST_${pastH.toFixed(1)}H • FUT_${futH.toFixed(1)}H`
                            : `RAINVIEWER • PAST_${pastH.toFixed(1)}H`;
                    }
                } catch (e) {}

                // Update labels + apply layer
                updateRadarLayer();

                // Light prefetch warm-up so scrubbing doesn't flash on the first few frames
                try {
                    setTimeout(function(){
                        try { prefetchRadarTiles(); } catch (e) {}
                    }, 250);
                } catch (e) {}

                if (els.radarOverlay) els.radarOverlay.classList.add('hidden');
            } catch (e) {
                console.error(e);
                if (els.radarOverlayTitle) els.radarOverlayTitle.innerText = 'RADAR_INIT_FAILED';
                if (els.radarOverlaySub) els.radarOverlaySub.innerText = 'NETWORK_OR_CORS_ERROR';
                if (els.radarOverlay) els.radarOverlay.classList.remove('hidden');
            }
        }

        function formatClockFromDate(d) {
            var hh = String(d.getHours()).padStart(2, '0');
            var mm = String(d.getMinutes()).padStart(2, '0');
            if (state.timeFormat === '24') return `${hh}:${mm}`;
            var h = d.getHours();
            var ampm = h >= 12 ? 'PM' : 'AM';
            h = h % 12;
            h = h ? h : 12;
            return `${h}:${mm} ${ampm}`;
        }

        function findNearestRadarFrameIndex(targetSec) {
            var frames = state.radar.frames || [];
            if (!frames.length) return 0;
            var bestIdx = 0;
            var bestDiff = Infinity;
            for (var i = 0; i < frames.length; i++) {
                var diff = Math.abs(frames[i].time - targetSec);
                if (diff < bestDiff) { bestDiff = diff; bestIdx = i; }
            }
            return bestIdx;
        }

        function updateRadarSelectedTimeLabel() {
            // Timeline label shows the *selected time* (minute-by-minute), even if
            // the map is rendering the nearest available radar frame.
            if (!els.radarFrameLabel) return;

            var minT = state.radar.minTimeSec;
            var maxT = state.radar.maxTimeSec;
            var sel = state.radar.selectedTimeSec;

            if (minT === null || maxT === null || sel === null || sel === undefined) {
                els.radarFrameLabel.innerText = '--:--';
                return;
            }

            // Clamp & format
            if (sel < minT) sel = minT;
            if (sel > maxT) sel = maxT;
            var d = new Date(sel * 1000);
            els.radarFrameLabel.innerText = formatClockFromDate(d);
        }

        function updateRadarFrameLabel() {
            // Map corner readout shows the actual RainViewer frame time
            var frames = state.radar.frames;
            if (!frames || frames.length === 0) return;
            var frame = frames[state.radar.frameIndex];
            if (!frame) return;
            var d = new Date(frame.time * 1000);
            var label = formatClockFromDate(d);
            if (els.radarFrameTime) els.radarFrameTime.innerText = label;
        }

        function updateRadarLayer() {
            if (!state.radar.map) return;
            // Timeline label shows the user's selected time on the ±12h slider
            updateRadarSelectedTimeLabel();
            // Corner readout shows the actual nearest radar frame time
            updateRadarFrameLabel();

            // TEMP layer follows the timeline too (independent of precip visibility)
            if (state.radar.tempEnabled) {
                try { updateTempLayer(false); } catch (e) {}
            }

            // Apply precip if enabled
            if (!state.radar.precipEnabled) {
                // If precip disabled, remove any existing precip layers
                if (state.radar.rainviewer) {
                    try { state.radar.map.removeLayer(state.radar.rainviewer); } catch (e) {}
                    state.radar.rainviewer = null;
                }
                if (state.radar.rainviewerPending) {
                    try { state.radar.map.removeLayer(state.radar.rainviewerPending); } catch (e) {}
                    state.radar.rainviewerPending = null;
                }
                state.radar.rainviewerPath = null;
                return;
            }

            var frames = state.radar.frames;
            if (!frames || frames.length === 0) return;

            var frame = frames[state.radar.frameIndex];
            if (!frame || !frame.path) return;

            // No-op if already showing this frame
            if (state.radar.rainviewerPath === frame.path && state.radar.rainviewer) {
                // ensure temp stays on top
                if (state.radar.tempLayer) {
                    try {
                        state.radar.tempLayer.eachLayer(function(l){
                            if (l && l.bringToFront) l.bringToFront();
                        });
                    } catch (e) {}
                }
                return;
            }

            // Remove any pending layer from previous request
            if (state.radar.rainviewerPending) {
                try { state.radar.map.removeLayer(state.radar.rainviewerPending); } catch (e) {}
                state.radar.rainviewerPending = null;
            }

            // Tile URL format
            var url = `https://tilecache.rainviewer.com/v2/radar/${frame.path}/256/{z}/{x}/{y}/2/1_1.png`;

            // Double-buffer: keep the current frame visible while the next frame loads.
            // Key trick: add the pending layer at opacity 0 so it doesn't cover the old frame,
            // then swap + set opacity only after at least one tile has loaded.
            var pending = L.tileLayer(url, {
                opacity: 0,
                zIndex: 1000,
                tileSize: 256,
                crossOrigin: true,
                keepBuffer: 4,
                updateWhenIdle: true,
                updateWhenZooming: false,
                fadeAnimation: false,
                attribution: 'Radar &copy; RainViewer'
            });

            state.radar.rainviewerPending = pending;

            var swapped = false;
            var hasTile = false;
            var timer = null;

            function swapIn() {
                // If the user scrubbed again, this pending layer is obsolete; don't swap it in.
                if (state.radar.rainviewerPending !== pending && state.radar.rainviewer !== pending) return;
                if (swapped) return;
                swapped = true;

                try { if (timer) clearTimeout(timer); } catch (e) {}

                // Make the pending layer visible now that it has tiles.
                try { pending.setOpacity(0.65); } catch (e) {}

                // Swap: remove old after new is in
                if (state.radar.rainviewer) {
                    try { state.radar.map.removeLayer(state.radar.rainviewer); } catch (e) {}
                }

                state.radar.rainviewer = pending;
                state.radar.rainviewerPending = null;
                state.radar.rainviewerPath = frame.path;

                // Ensure temp overlay above tiles
                if (state.radar.tempLayer) {
                    try {
                        state.radar.tempLayer.eachLayer(function(l){
                            if (l && l.bringToFront) l.bringToFront();
                        });
                    } catch (e) {}
                }

                // Warm cache for nearby frames (small prefetch)
                try { prefetchRadarTiles(); } catch (e) {}
            }

            // Start loading immediately, but keep it invisible until tiles arrive.
            pending.addTo(state.radar.map);

            // Swap on first tile load (not on a timer) to prevent blank-frame flashing.
            pending.on('tileload', function(){
                if (hasTile) return;
                hasTile = true;
                swapIn();
            });

            // If it takes too long, discard the pending layer and keep the old one.
            timer = setTimeout(function(){
                if (hasTile) return;
                try { state.radar.map.removeLayer(pending); } catch (e) {}
                if (state.radar.rainviewerPending === pending) state.radar.rainviewerPending = null;
            }, 5000);

            pending.on('tileerror', function(){
                try { if (timer) clearTimeout(timer); } catch (e) {}
                try { state.radar.map.removeLayer(pending); } catch (e) {}
                if (state.radar.rainviewerPending === pending) state.radar.rainviewerPending = null;
            });
        }

        async function updateTempLayer(force) {
            if (!state.radar.map) return;

            // Toggle off: remove layer
            if (!state.radar.tempEnabled) {
                if (state.radar.tempLayer) {
                    try { state.radar.map.removeLayer(state.radar.tempLayer); } catch (e) {}
                    state.radar.tempLayer = null;
                }
                return;
            }

            // Ensure base temp layer exists (current visible)
            if (!state.radar.tempLayer) {
                state.radar.tempLayer = L.layerGroup().addTo(state.radar.map);
            }

            // Clear any previous pending group
            if (state.radar.tempLayerPending) {
                try { state.radar.map.removeLayer(state.radar.tempLayerPending); } catch (e) {}
                state.radar.tempLayerPending = null;
            }

            if (state.radar.tempBusy) return;
            state.radar.tempBusy = true;

            // Render into a pending layer group to avoid flashing
            var pendingGroup = L.layerGroup();
            state.radar.tempLayerPending = pendingGroup;

            // Debounce/caching by approximate bounds key (prevents refetching on tiny pans)
            var b = state.radar.map.getBounds();
            // Include current radar frame time (rounded to 15min) so scrubbing the timeline updates the temps
            var frameKey = 'now';
            var tf = state.radar.frames;
            if (tf && tf.length && tf[state.radar.frameIndex]) {
                var tSec = tf[state.radar.frameIndex].time;
                frameKey = Math.round(tSec / (15 * 60)) * (15 * 60);
            }

            var key = [
                b.getSouth().toFixed(1),
                b.getWest().toFixed(1),
                b.getNorth().toFixed(1),
                b.getEast().toFixed(1),
                state.radar.map.getZoom(),
                frameKey
            ].join(',');

            if (!force && state.radar.tempLastBoundsKey === key) {
                state.radar.tempBusy = false;
                return;
            }
            state.radar.tempLastBoundsKey = key;

            // UI overlay
            try {
                if (els.radarOverlayTitle) els.radarOverlayTitle.innerText = 'ACQUIRING_TEMP...';
                if (els.radarOverlaySub) els.radarOverlaySub.innerText = 'OPEN_METEO_HOURLY • FRAME_SYNCED';
                if (els.radarOverlay) els.radarOverlay.classList.remove('hidden');
            } catch (e) {}

            // Bounds
            var south = b.getSouth();
            var north = b.getNorth();
            var west = b.getWest();
            var east = b.getEast();

            // Handle antimeridian wrap (Leaflet may give east < west)
            var lonSpan = east - west;
            if (lonSpan < 0) lonSpan += 360;

            function normLon(l) {
                var x = l;
                while (x > 180) x -= 360;
                while (x < -180) x += 360;
                return x;
            }

            // Display grid (high resolution rectangles)
            var z = state.radar.map.getZoom();
            var grid = 7;
            if (z <= 3) grid = 5;
            else if (z <= 5) grid = 7;
            else if (z <= 7) grid = 9;
            else if (z <= 9) grid = 10;
            else if (z <= 11) grid = 11;
            else grid = 12;

            // Sample grid (limits Open‑Meteo requests to speed up): max 8x8 = 64 requests
            var sampleGrid = grid;
            if (sampleGrid > 8) sampleGrid = 8;

            var latStepS = (north - south) / sampleGrid;
            var lonStepS = lonSpan / sampleGrid;

            var sampleCells = [];
            for (var sr = 0; sr < sampleGrid; sr++) {
                for (var sc = 0; sc < sampleGrid; sc++) {
                    var lat0s = south + sr * latStepS;
                    var lat1s = south + (sr + 1) * latStepS;

                    var lon0s = west + sc * lonStepS;
                    var lon1s = west + (sc + 1) * lonStepS;
                    lon0s = normLon(lon0s);
                    lon1s = normLon(lon1s);

                    var clats = (lat0s + lat1s) / 2;
                    var clons = normLon((lon0s + lon1s) / 2);

                    sampleCells.push({
                        r: sr,
                        c: sc,
                        lat: clats,
                        lon: clons
                    });
                }
            }

            function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
            function lerp(a, b, t) { return a + (b - a) * t; }
            function mix(c1, c2, t) {
                return [
                    Math.round(lerp(c1[0], c2[0], t)),
                    Math.round(lerp(c1[1], c2[1], t)),
                    Math.round(lerp(c1[2], c2[2], t))
                ];
            }
            function tempToColor(tempC) {
                // Match legend: light blue -> green -> yellow -> orange -> red
                var min = -10;
                var max = 40;
                var t = clamp((tempC - min) / (max - min), 0, 1);

                var stops = [
                    { t: 0.00, c: [125, 211, 252] }, // #7dd3fc
                    { t: 0.25, c: [ 74, 222, 128] }, // #4ade80
                    { t: 0.50, c: [253, 224,  71] }, // #fde047
                    { t: 0.75, c: [251, 146,  60] }, // #fb923c
                    { t: 1.00, c: [239,  68,  68] }  // #ef4444
                ];

                var i = 0;
                while (i < stops.length - 1 && t > stops[i + 1].t) i++;
                var a = stops[i];
                var b = stops[Math.min(i + 1, stops.length - 1)];
                var segT = (b.t === a.t) ? 0 : (t - a.t) / (b.t - a.t);
                var rgb = mix(a.c, b.c, segT);
                return `rgba(${rgb[0]},${rgb[1]},${rgb[2]},0.22)`;
            }

            // Determine target time from the RADAR timeline (RainViewer frame time)
            // If frames are unavailable, fallback to "now".
            var targetMs = Date.now();
            var tf2 = state.radar.frames;
            if (tf2 && tf2.length && tf2[state.radar.frameIndex]) {
                targetMs = tf2[state.radar.frameIndex].time * 1000;
            }

            // Fetch temps for sample points (hourly temperature_2m series) with cache + concurrency limit
            if (!state.radar.tempSeriesCache) state.radar.tempSeriesCache = {};
            var cache = state.radar.tempSeriesCache;
            function keyFor(lat, lon) {
                return lat.toFixed(2) + ',' + lon.toFixed(2);
            }

            function interpSeriesAt(series, targetMs) {
                if (!series || !series.times || !series.tempsC || !series.times.length) return null;
                var times = series.times;
                var temps = series.tempsC;

                // Binary-ish scan (arrays are small ~ 48–168); simple linear scan is fine.
                // Find the last time <= target
                var idx = 0;
                while (idx < times.length && times[idx] <= targetMs) idx++;
                idx = Math.max(1, idx); // ensure we have a previous

                var t0 = times[idx - 1];
                var t1 = times[Math.min(idx, times.length - 1)];
                var v0 = temps[idx - 1];
                var v1 = temps[Math.min(idx, temps.length - 1)];

                if (v0 === null || v0 === undefined) return null;
                if (t0 === t1 || v1 === null || v1 === undefined) return v0;

                var a = (targetMs - t0) / (t1 - t0);
                a = clamp(a, 0, 1);
                return v0 + (v1 - v0) * a;
            }

            async function fetchSampleTemp(cell) {
                var k = keyFor(cell.lat, cell.lon);
                if (cache[k] !== undefined) {
                    return { cell: cell, tempC: interpSeriesAt(cache[k], targetMs) };
                }
                try {
                    // Request hourly temperature for the last 2 days (covers RainViewer past frames + timezone offsets)
                    var url = `https://api.open-meteo.com/v1/forecast?latitude=${encodeURIComponent(cell.lat)}&longitude=${encodeURIComponent(cell.lon)}&hourly=temperature_2m&past_days=2&forecast_days=1&timezone=auto`;
                    var res = await fetch(url);
                    var data = await res.json();

                    var times = (data && data.hourly && data.hourly.time) ? data.hourly.time : [];
                    var tempsC = (data && data.hourly && data.hourly.temperature_2m) ? data.hourly.temperature_2m : [];

                    // Convert ISO strings to ms
                    var ms = [];
                    for (var ti = 0; ti < times.length; ti++) {
                        var d = new Date(times[ti]);
                        var m = d.getTime();
                        ms.push(m);
                    }

                    cache[k] = { times: ms, tempsC: tempsC };
                    return { cell: cell, tempC: interpSeriesAt(cache[k], targetMs) };
                } catch (e) {
                    cache[k] = null;
                    return { cell: cell, tempC: null };
                }
            }

            async function mapLimit(items, limit, fn) {
                var out = new Array(items.length);
                var idx = 0;
                var workers = new Array(Math.min(limit, items.length)).fill(0).map(async function(){
                    while (idx < items.length) {
                        var my = idx++;
                        out[my] = await fn(items[my]);
                    }
                });
                await Promise.all(workers);
                return out;
            }

            var sampleResults = await mapLimit(sampleCells, 12, fetchSampleTemp);

            // Count successes; if most failed, keep previous layer
            var okCount = 0;
            for (var ck = 0; ck < sampleResults.length; ck++) {
                if (sampleResults[ck] && sampleResults[ck].tempC !== null && sampleResults[ck].tempC !== undefined) okCount++;
            }
            if (okCount < Math.max(3, Math.floor(sampleResults.length * 0.2))) {
                // Too many failures: keep the current visible temp layer (no flashing)
                try {
                    if (state.radar.tempLayerPending) {
                        try { state.radar.map.removeLayer(state.radar.tempLayerPending); } catch (e) {}
                        state.radar.tempLayerPending = null;
                    }
                } catch (e) {}

                try {
                    if (els.radarOverlayTitle) els.radarOverlayTitle.innerText = 'TEMP_LAYER_LIMITED';
                    if (els.radarOverlaySub) els.radarOverlaySub.innerText = 'RATE_LIMIT_OR_NETWORK • RETRY';
                    setTimeout(function(){ try { if (els.radarOverlay) els.radarOverlay.classList.add('hidden'); } catch(e) {} }, 800);
                } catch (e) {}

                state.radar.tempBusy = false;
                return;
            }

            // Build sample matrix
            var sampleTemps = [];
            for (var r = 0; r < sampleGrid; r++) sampleTemps[r] = new Array(sampleGrid).fill(null);
            for (var si = 0; si < sampleResults.length; si++) {
                var sr = sampleResults[si].cell.r;
                var sc = sampleResults[si].cell.c;
                sampleTemps[sr][sc] = sampleResults[si].tempC;
            }

            // Bilinear interpolation (with nearest-neighbor fallback)
            function interpTemp(u, v) {
                var fr = u * (sampleGrid - 1);
                var fc = v * (sampleGrid - 1);
                var r0 = Math.floor(fr);
                var c0 = Math.floor(fc);
                var r1 = Math.min(r0 + 1, sampleGrid - 1);
                var c1 = Math.min(c0 + 1, sampleGrid - 1);
                var tr = fr - r0;
                var tc = fc - c0;

                var t00 = sampleTemps[r0][c0];
                var t01 = sampleTemps[r0][c1];
                var t10 = sampleTemps[r1][c0];
                var t11 = sampleTemps[r1][c1];

                // If any missing, fallback to nearest available among the 4
                if (t00 === null || t01 === null || t10 === null || t11 === null ||
                    t00 === undefined || t01 === undefined || t10 === undefined || t11 === undefined) {
                    var rn = Math.round(fr);
                    var cn = Math.round(fc);
                    rn = clamp(rn, 0, sampleGrid - 1);
                    cn = clamp(cn, 0, sampleGrid - 1);
                    var nn = sampleTemps[rn][cn];
                    if (nn !== null && nn !== undefined) return nn;
                    // try the four corners
                    var candidates = [t00, t01, t10, t11].filter(v => v !== null && v !== undefined);
                    if (candidates.length) return candidates[0];
                    return null;
                }

                // Standard bilinear
                var a = t00 * (1 - tc) + t01 * tc;
                var b = t10 * (1 - tc) + t11 * tc;
                return a * (1 - tr) + b * tr;
            }

            // Clear & render
            // (Do not clear the current visible layer here; we render into pendingGroup)

            // Display grid steps
            var latStep = (north - south) / grid;
            var lonStep = lonSpan / grid;

            // Matrices for labels
            var temps = [];
            var centerLats = [];
            var centerLons = [];
            for (var rr = 0; rr < grid; rr++) {
                temps[rr] = new Array(grid).fill(null);
                centerLats[rr] = new Array(grid).fill(null);
                centerLons[rr] = new Array(grid).fill(null);
            }

            // Render rectangles (high-res) using interpolated temps
            for (var r = 0; r < grid; r++) {
                for (var c = 0; c < grid; c++) {
                    var u = (r + 0.5) / grid;
                    var v = (c + 0.5) / grid;
                    var tC = interpTemp(u, v);
                    temps[r][c] = tC;

                    var lat0 = south + r * latStep;
                    var lat1 = south + (r + 1) * latStep;

                    var lon0 = normLon(west + c * lonStep);
                    var lon1 = normLon(west + (c + 1) * lonStep);

                    var clat = (lat0 + lat1) / 2;
                    var clon = normLon((lon0 + lon1) / 2);
                    centerLats[r][c] = clat;
                    centerLons[r][c] = clon;

                    if (tC === null || tC === undefined) continue;

                    var color = tempToColor(tC);
                    try {
                        L.rectangle([[lat0, lon0], [lat1, lon1]], {
                            stroke: false,
                            fillColor: color,
                            fillOpacity: 1,
                            interactive: false
                        }).addTo(pendingGroup);
                    } catch (e) {}
                }
            }

            // Helper: average longitudes safely (handles antimeridian)
            function avgLon(lons) {
                var x = 0, y = 0;
                for (var i = 0; i < lons.length; i++) {
                    var rad = lons[i] * Math.PI / 180;
                    x += Math.cos(rad);
                    y += Math.sin(rad);
                }
                var ang = Math.atan2(y / lons.length, x / lons.length);
                var deg = ang * 180 / Math.PI;
                while (deg > 180) deg -= 360;
                while (deg < -180) deg += 360;
                return deg;
            }

            // Labels:
            // - Zoom < 11: label every cell
            // - Zoom >= 11: label every 2x2 block, average of 4 (rounded up)
            var zNow = state.radar.map.getZoom();
            var labelMode = (zNow >= 11) ? 'block2' : 'cell';

            function formatTempLabel(tempC, roundUp) {
                var v = tempC;
                var unit = '°C';
                if (state.unit === 'f') {
                    v = (v * 9/5) + 32;
                    unit = '°F';
                }
                var n = roundUp ? Math.ceil(v) : Math.round(v);
                return n + unit;
            }

            if (labelMode === 'cell') {
                for (var r3 = 0; r3 < grid; r3++) {
                    for (var c3 = 0; c3 < grid; c3++) {
                        var tC3 = temps[r3][c3];
                        if (tC3 === null || tC3 === undefined) continue;
                        try {
                            var icon = L.divIcon({
                                className: 'temp-div-icon',
                                html: `<div class="temp-grid-label">${formatTempLabel(tC3, false)}</div>`,
                                iconSize: [0, 0]
                            });
                            L.marker([centerLats[r3][c3], centerLons[r3][c3]], {
                                icon: icon,
                                interactive: false,
                                keyboard: false
                            }).addTo(pendingGroup);
                        } catch (e) {}
                    }
                }
            } else {
                for (var r2 = 0; r2 < grid - 1; r2 += 2) {
                    for (var c2 = 0; c2 < grid - 1; c2 += 2) {
                        var t00 = temps[r2][c2];
                        var t01 = temps[r2][c2 + 1];
                        var t10 = temps[r2 + 1][c2];
                        var t11 = temps[r2 + 1][c2 + 1];

                        if (t00 === null || t01 === null || t10 === null || t11 === null ||
                            t00 === undefined || t01 === undefined || t10 === undefined || t11 === undefined) {
                            continue;
                        }

                        var avgC = (t00 + t01 + t10 + t11) / 4;
                        var latCenter = (centerLats[r2][c2] + centerLats[r2][c2 + 1] + centerLats[r2 + 1][c2] + centerLats[r2 + 1][c2 + 1]) / 4;
                        var lonCenter = avgLon([centerLons[r2][c2], centerLons[r2][c2 + 1], centerLons[r2 + 1][c2], centerLons[r2 + 1][c2 + 1]]);

                        try {
                            var iconB = L.divIcon({
                                className: 'temp-div-icon',
                                html: `<div class="temp-grid-label">${formatTempLabel(avgC, true)}</div>`,
                                iconSize: [0, 0]
                            });
                            L.marker([latCenter, lonCenter], {
                                icon: iconB,
                                interactive: false,
                                keyboard: false
                            }).addTo(pendingGroup);
                        } catch (e) {}
                    }
                }
            }

            // Swap pending group in (avoids flashing)
            try {
                if (state.radar.tempLayer) state.radar.map.removeLayer(state.radar.tempLayer);
            } catch (e) {}
            try {
                pendingGroup.addTo(state.radar.map);
            } catch (e) {}
            state.radar.tempLayer = pendingGroup;
            state.radar.tempLayerPending = null;

            // Keep above base tiles
            try {
                state.radar.tempLayer.eachLayer(function(l){
                    if (l && l.bringToFront) l.bringToFront();
                });
            } catch (e) {}

            // Hide overlay
            try { if (els.radarOverlay) els.radarOverlay.classList.add('hidden'); } catch (e) {}

            state.radar.tempBusy = false;
        }

        function syncRadarLayerButtons() {
            function setActive(btn) {
                btn.classList.add('bg-accent', 'text-white', 'border-accent');
                btn.classList.remove('bg-[var(--card-bg)]');
            }
            function setInactive(btn) {
                btn.classList.remove('bg-accent', 'text-white', 'border-accent');
                btn.classList.add('bg-[var(--card-bg)]');
            }

            if (els.radarLayerPrecip) (state.radar.precipEnabled ? setActive(els.radarLayerPrecip) : setInactive(els.radarLayerPrecip));
            if (els.radarLayerTemp) (state.radar.tempEnabled ? setActive(els.radarLayerTemp) : setInactive(els.radarLayerTemp));
        }


        // Prefetch a small set of radar tiles around the current frame to reduce flashing while scrubbing.
        // This is intentionally bounded (a few frames, a few tiles) to avoid heavy bandwidth.
        function prefetchRadarTiles() {
            if (!state.radar || !state.radar.map) return;
            var frames = state.radar.frames || [];
            if (!frames.length) return;

            // Limit frequency
            if (state.radar._prefetchTimer) return;
            state.radar._prefetchTimer = setTimeout(function(){ state.radar._prefetchTimer = null; }, 900);

            var z = state.radar.map.getZoom();
            var c = state.radar.map.getCenter();

            // Compute tile x/y for a few zooms (z and z+1) and a 3x3 neighborhood.
            function lon2x(lon, zoom) {
                return Math.floor((lon + 180) / 360 * Math.pow(2, zoom));
            }
            function lat2y(lat, zoom) {
                var rad = lat * Math.PI / 180;
                return Math.floor((1 - Math.log(Math.tan(rad) + 1 / Math.cos(rad)) / Math.PI) / 2 * Math.pow(2, zoom));
            }

            var zooms = [z, Math.min(z + 1, 18)];

            // Prefetch a few frames around the current index
            var idx = state.radar.frameIndex || 0;
            var frameIdxs = [idx - 2, idx - 1, idx, idx + 1, idx + 2].filter(i => i >= 0 && i < frames.length);

            // Store a tiny LRU-ish set so we don't keep growing memory
            if (!state.radar._prefetched) state.radar._prefetched = {};

            frameIdxs.forEach(function(fi){
                var frame = frames[fi];
                if (!frame || !frame.path) return;

                zooms.forEach(function(zz){
                    var tx = lon2x(c.lng, zz);
                    var ty = lat2y(c.lat, zz);

                    for (var dx = -1; dx <= 1; dx++) {
                        for (var dy = -1; dy <= 1; dy++) {
                            var x = tx + dx;
                            var y = ty + dy;
                            var key = frame.path + '|' + zz + '|' + x + '|' + y;
                            if (state.radar._prefetched[key]) continue;
                            state.radar._prefetched[key] = 1;

                            var img = new Image();
                            img.decoding = 'async';
                            img.loading = 'eager';
                            img.src = `https://tilecache.rainviewer.com/v2/radar/${frame.path}/256/${zz}/${x}/${y}/2/1_1.png`;
                        }
                    }
                });
            });

            // Trim the prefetch map if it grows too big
            try {
                var keys = Object.keys(state.radar._prefetched);
                if (keys.length > 600) {
                    for (var i = 0; i < 200; i++) {
                        delete state.radar._prefetched[keys[i]];
                    }
                }
            } catch (e) {}
        }

        function syncRadarPlaybackButton() {
            if (!els.radarPlayIcon || !els.radarPlayToggle) return;

            // Inline SVG icons (reliable, no external icon-class dependency)
            var playSvg = `
                <svg viewBox="0 0 24 24" width="26" height="26" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                    <path d="M9 7L18 12L9 17V7Z" fill="currentColor" stroke="currentColor" stroke-width="1" stroke-linejoin="miter"/>
                </svg>
            `;
            var pauseSvg = `
                <svg viewBox="0 0 24 24" width="26" height="26" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                    <path d="M7 6H10V18H7V6Z" fill="currentColor" stroke="currentColor" stroke-width="1" stroke-linejoin="miter"/>
                    <path d="M14 6H17V18H14V6Z" fill="currentColor" stroke="currentColor" stroke-width="1" stroke-linejoin="miter"/>
                </svg>
            `;

            if (state.radar.playing) {
                els.radarPlayIcon.innerHTML = pauseSvg;
                els.radarPlayToggle.classList.add('bg-accent', 'text-white', 'border-accent');
                els.radarPlayToggle.classList.remove('bg-[var(--card-bg)]');
            } else {
                els.radarPlayIcon.innerHTML = playSvg;
                els.radarPlayToggle.classList.remove('bg-accent', 'text-white', 'border-accent');
                els.radarPlayToggle.classList.add('bg-[var(--card-bg)]');
            }
        }

        function startRadarPlayback() {
            if (state.radar.timer) return;
            var frames = state.radar.frames;
            if (!frames || frames.length === 0) return;
            if (state.radar.minTimeSec === null || state.radar.maxTimeSec === null) return;

            state.radar.playing = true;
            syncRadarPlaybackButton();

            state.radar.timer = setInterval(() => {
                var frames = state.radar.frames || [];
                if (!frames.length) return;

                var next = (state.radar.frameIndex || 0) + 1;
                if (next > frames.length - 1) next = 0;

                state.radar.frameIndex = next;
                state.radar.selectedTimeSec = frames[next].time;

                if (els.radarFrameSlider) {
                    els.radarFrameSlider.value = next;
                }

                updateRadarLayer();
                try { prefetchRadarTiles(); } catch (e) {}
            }, 650);
        }

        function stopRadarPlayback() {
            state.radar.playing = false;
            if (state.radar.timer) {
                clearInterval(state.radar.timer);
                state.radar.timer = null;
            }
            syncRadarPlaybackButton();
        }

        // --- Settings ---
        function applySettings() {
            // Theme
            if (state.theme === 'dark') {
                els.body.classList.add('dark-mode');
                updateBtnState(els.themeDark, els.themeLight);
            } else {
                els.body.classList.remove('dark-mode');
                updateBtnState(els.themeLight, els.themeDark);
            }

            // Unit
            if (state.unit === 'f') {
                updateBtnState(els.unitF, els.unitC);
            } else {
                updateBtnState(els.unitC, els.unitF);
            }
            
            // Time
            if (state.timeFormat === '12') {
                updateBtnState(els.time12, els.time24);
            } else {
                updateBtnState(els.time24, els.time12);
            }

            // Wind speed unit
            if (state.windSpeedUnit === 'mph') {
                updateBtnState(els.windMph, els.windKmh);
            } else {
                updateBtnState(els.windKmh, els.windMph);
            }

            // Accent
            document.documentElement.style.setProperty('--accent-color', state.accent);

            // Re-render
            if (state.weatherData) renderWeather();

            // Radar: keep map sized correctly, swap base tiles for theme, and keep frame label in sync with time format
            if (state.radar && state.radar.inited && state.radar.map) {
                try { state.radar.map.invalidateSize(); } catch (e) {}

                // Swap radar basemap to match theme (OSM light / CartoDB dark)
                try {
                    var url = (state.theme === 'dark')
                        ? 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png'
                        : 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
                    if (state.radar.base && state.radar.base.setUrl) state.radar.base.setUrl(url);
                } catch (e) {}

                updateRadarFrameLabel();
                if (state.radar.tempEnabled) {
                    try { updateTempLayer(true); } catch (e) {}
                }
            }
        }

        function updateBtnState(active, inactive) {
            // Active button: accent fill
            active.classList.add('bg-accent', 'text-white', 'border-accent');
            active.classList.remove('bg-[var(--card-bg)]', 'border-[var(--card-border)]', 'border-[var(--text-color)]', 'text-[var(--text-color)]');

            // Inactive button: strong visible outline in BOTH themes
            inactive.classList.remove('bg-accent', 'text-white', 'border-accent');
            inactive.classList.add('bg-[var(--card-bg)]', 'border-[var(--text-color)]', 'text-[var(--text-color)]');
            inactive.classList.remove('border-[var(--card-border)]');
        }

        function setupEvents() {
            els.themeLight.onclick = () => { state.theme = 'light'; persistStore('mw_theme', 'light'); applySettings(); };
            els.themeDark.onclick = () => { state.theme = 'dark'; persistStore('mw_theme', 'dark'); applySettings(); };
            
            els.unitC.onclick = () => { state.unit = 'c'; persistStore('mw_unit', 'c'); applySettings(); };
            els.unitF.onclick = () => { state.unit = 'f'; persistStore('mw_unit', 'f'); applySettings(); };
            
            els.time24.onclick = () => { state.timeFormat = '24'; persistStore('mw_time', '24'); applySettings(); };
            els.time12.onclick = () => { state.timeFormat = '12'; persistStore('mw_time', '12'); applySettings(); };

            els.windKmh.onclick = () => { state.windSpeedUnit = 'kmh'; persistStore('mw_wind_unit', 'kmh'); applySettings(); };
            els.windMph.onclick = () => { state.windSpeedUnit = 'mph'; persistStore('mw_wind_unit', 'mph'); applySettings(); };
            
            els.colorPicker.onclick = (e) => {
                if(e.target.dataset.color) {
                    state.accent = e.target.dataset.color;
                    persistStore('mw_accent', state.accent);
                    applySettings();
                }
            };

            els.searchBtn.onclick = () => {
                els.dropdown.classList.add('hidden');
                els.dropdown.innerHTML = '';
                handleSearch(els.search.value);
            };
            els.search.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    els.dropdown.classList.add('hidden');
                    els.dropdown.innerHTML = '';
                    handleSearch(els.search.value);
                }
            };
            
            var debounce;
            els.search.oninput = (e) => {
                clearTimeout(debounce);
                var val = e.target.value.trim();
                if(val.length < 2) {
                    els.dropdown.classList.add('hidden');
                    return;
                }
                debounce = setTimeout(() => fetchSuggestions(val), 300);
            };
            
            document.onclick = (e) => {
                if(!els.dropdown.contains(e.target) && e.target !== els.search) {
                    els.dropdown.classList.add('hidden');
                }
            };
        }

        // --- Data Logic ---
        async function fetchSuggestions(query) {
            try {
                var res = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=5&language=en&format=json`);
                var data = await res.json();
                
                els.dropdown.innerHTML = '';
                if(data.results) {
                    data.results.forEach(city => {
                        var div = document.createElement('div');
                        div.className = 'p-6 hover:bg-accent hover:text-white cursor-pointer border-b-2 border-[var(--text-color)] last:border-0 font-mono text-lg md:text-xl uppercase transition-colors font-bold';
                        div.innerText = `${city.name}, ${city.admin1 || ''} ${city.country_code}`;
                        div.onclick = () => {
                            els.search.value = city.name;
                            els.dropdown.classList.add('hidden');
                            handleSearchWithCoords(city);
                        };
                        els.dropdown.appendChild(div);
                    });
                    els.dropdown.classList.remove('hidden');
                } else {
                    els.dropdown.classList.add('hidden');
                }
            } catch(e) { console.error(e); }
        }

        async function handleSearch(term) {
            if(!term) return;
            els.dropdown.classList.add('hidden');
            els.error.innerText = '';
            els.loading.classList.remove('hidden');
            els.content.classList.add('hidden');

            try {
                var res = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(term)}&count=1&language=en&format=json`);
                var data = await res.json();
                if(!data.results) throw new Error("City not found");
                handleSearchWithCoords(data.results[0]);
            } catch(e) {
                els.loading.classList.add('hidden');
                els.error.innerText = 'ERROR: CITY_NOT_FOUND';
            }
        }

        async function handleSearchWithCoords(city) {
            state.cityData = city;

            // Persist last selected city in cookies/localStorage (so we can restore on refresh)
            try {
                var savedCity = {
                    name: city.name,
                    admin1: city.admin1 || null,
                    country_code: city.country_code || null,
                    latitude: city.latitude,
                    longitude: city.longitude
                };
                persistStore('mw_last_city', JSON.stringify(savedCity));
            } catch (e) {}
            
            // Auto-localization
            // Applies defaults based on country *only if the user hasn't explicitly set prefs yet*
            // (prefs stored in cookies/localStorage)
            if (city.country_code) {
                var shouldSetUnits = !hasCookie('mw_unit') && !(localStorage.getItem('mw_unit'));
                var shouldSetTime = !hasCookie('mw_time') && !(localStorage.getItem('mw_time'));
                var shouldSetWind = !hasCookie('mw_wind_unit') && !(localStorage.getItem('mw_wind_unit'));

                if (imperialCountries.includes(city.country_code)) {
                    if (shouldSetUnits) state.unit = 'f';
                    if (shouldSetTime) state.timeFormat = '12';
                    if (shouldSetWind) state.windSpeedUnit = 'mph';
                } else {
                    if (shouldSetUnits) state.unit = 'c';
                    if (shouldSetTime) state.timeFormat = '24';
                    if (shouldSetWind) state.windSpeedUnit = 'kmh';
                }

                // Persist any auto-applied defaults
                if (shouldSetUnits) persistStore('mw_unit', state.unit);
                if (shouldSetTime) persistStore('mw_time', state.timeFormat);
                if (shouldSetWind) persistStore('mw_wind_unit', state.windSpeedUnit);

                applySettings();
            }

            els.loading.classList.remove('hidden');
            els.content.classList.add('hidden');
            els.error.innerText = '';

            try {
                // Open-Meteo Forecast (minimal, widely-supported set; no moon_phase)
                var url = `https://api.open-meteo.com/v1/forecast?latitude=${city.latitude}&longitude=${city.longitude}&current_weather=true&hourly=temperature_2m,apparent_temperature,relativehumidity_2m,surface_pressure,visibility,cloudcover,precipitation,rain,showers,snowfall,windspeed_10m,winddirection_10m,uv_index&daily=weathercode,temperature_2m_max,temperature_2m_min,sunrise,sunset,uv_index_max&forecast_days=4&timezone=auto`;
                var res = await fetch(url);
                if (!res.ok) throw new Error('HTTP_' + res.status);
                var data = await res.json();
                if (!data || data.error || !data.current_weather || !data.hourly || !data.daily) {
                    throw new Error((data && (data.reason || data.message)) || 'OPEN_METEO_ERROR');
                }
                state.weatherData = data;

                renderWeather();

                // If radar is initialized, center map on the selected city and update marker
            if (state.radar && state.radar.inited && state.radar.map) {
                try {
                    state.radar.map.setView([city.latitude, city.longitude], 7);
                    if (state.radar.marker) {
                        state.radar.marker.setLatLng([city.latitude, city.longitude]);
                    } else {
                        state.radar.marker = L.marker([city.latitude, city.longitude]).addTo(state.radar.map);
                    }
                } catch (e) {}
            }


                els.loading.classList.add('hidden');
                els.content.classList.remove('hidden');
            } catch(e) {
                console.error(e);
                els.loading.classList.add('hidden');
                els.error.innerText = 'ERROR: DATA_FETCH_FAILED';
            }
        }

        function formatTime(isoString) {
            if (!isoString) return '--:--';
            var timePart = isoString.split('T')[1];
            if (!timePart) return '--:--';
            
            if (state.timeFormat === '24') {
                return timePart;
            } else {
                var parts = timePart.split(':');
                var h = parseInt(parts[0]);
                var m = parts[1];
                var ampm = h >= 12 ? 'PM' : 'AM';
                h = h % 12;
                h = h ? h : 12; 
                return `${h}:${m} ${ampm}`;
            }
        }

        // --- Descriptions Logic ---
        function getWindDesc(speed) {
            // Speed comes in km/h from processing or mph
            // But logic was based on raw data.
            // Wait, in renderWeather I process it.
            // I'll take processed value if possible, or handle unit check here.
            // Speed passed to this function will be consistent with state.unit
            // No, better to pass RAW km/h or consistently process.
            // I'll pass the raw value from API (km/h) for logic.
            if (speed < 10) return "CALM";
            if (speed < 30) return "BREEZY";
            if (speed < 60) return "WINDY";
            return "GALE";
        }
        function getHumDesc(h) {
            if (h < 30) return "DRY";
            if (h < 60) return "COMFY";
            return "HUMID";
        }
        function getUVDesc(u) {
            if (u < 3) return "LOW";
            if (u < 6) return "MODERATE";
            if (u < 8) return "HIGH";
            return "EXTREME";
        }
        function getVisDesc(v) { // v in km
            if (v < 1) return "FOG";
            if (v < 10) return "HAZE";
            return "CLEAR";
        }
        function getPrecipDesc(p) { // p in mm
            if (p < 0.1) return "DRY";
            if (p < 2.5) return "LIGHT";
            if (p < 7.6) return "MODERATE";
            return "HEAVY";
        }
        function getCloudDesc(c) {
            if (c < 20) return "CLEAR";
            if (c < 60) return "PARTLY";
            return "OVERCAST";
        }
        function getPressDesc(p) {
            if (p < 1000) return "LOW";
            if (p < 1020) return "NORMAL";
            return "HIGH";
        }

        function renderWeather() {
            var current_weather = state.weatherData.current_weather;
            var daily = state.weatherData.daily;
            var hourly = state.weatherData.hourly;

            // Hourly index matching (used for all hourly cards)
            var hIdx = getHourlyIndex();
            
            // Header - City with State/Country
            var locationParts = [state.cityData.name];
            if (state.cityData.admin1) {
                // Use proper state abbreviation for US states
                if (state.cityData.country_code === 'US' && usStateAbbreviations[state.cityData.admin1]) {
                    locationParts.push(usStateAbbreviations[state.cityData.admin1]);
                } else if (state.cityData.admin1.length <= 3) {
                    // Already an abbreviation
                    locationParts.push(state.cityData.admin1);
                } else {
                    // Use country code as fallback
                    locationParts.push(state.cityData.country_code || state.cityData.admin1.substring(0, 2).toUpperCase());
                }
            } else if (state.cityData.country_code) {
                locationParts.push(state.cityData.country_code);
            }
            var locText = locationParts.join(', ');
            els.city.innerText = locText;
            if (els.radarTarget) els.radarTarget.innerText = locText.toUpperCase();
            
            var now = new Date();
            els.date.innerText = now.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' }).toUpperCase();
            
            // Main Weather
            var weatherInfo = weatherCodeMap[current_weather.weathercode] || { desc: 'Unknown', icon: 'wi wi-na' };
            els.desc.innerText = weatherInfo.desc;
            els.icon.className = `${weatherInfo.icon} text-7xl leading-none text-accent`;

            // Ensure the slider handle icon stays legible on the accent background
            try {
                if (els.handleIcon) els.handleIcon.classList.add('text-[var(--handle-text)]');
            } catch (e) {}

            // Update WEATHER tab icon in the slider to match current condition
            try { updateWeatherNavIcon(weatherInfo.icon); } catch (e) {}
            
            // Temp
            var t = current_weather.temperature;
            if(state.unit === 'f') t = (t * 9/5) + 32;
            els.temp.innerText = Math.round(t);
            els.unit.innerText = state.unit === 'c' ? '°C' : '°F';
            
            // High/Low
            var maxT = daily.temperature_2m_max[0];
            var minT = daily.temperature_2m_min[0];
            if(state.unit === 'f') {
                maxT = (maxT * 9/5) + 32;
                minT = (minT * 9/5) + 32;
            }
            els.high.innerText = Math.round(maxT);
            els.low.innerText = Math.round(minT);

            // FEELS LIKE (apparent temperature)
            try {
                var feelsC = (hourly.apparent_temperature && hourly.apparent_temperature[hIdx] !== undefined)
                    ? hourly.apparent_temperature[hIdx]
                    : null;
                if (feelsC === null || feelsC === undefined) {
                    if (els.feels) els.feels.innerText = '--';
                    if (els.tempDescBox) els.tempDescBox.innerText = '--';
                } else {
                    var feels = feelsC;
                    if (state.unit === 'f') feels = (feels * 9/5) + 32;
                    if (els.feels) els.feels.innerText = Math.round(feels);

                    // Simple descriptor based on delta between feels-like and actual
                    var deltaC = feelsC - current_weather.temperature;
                    var desc = 'NEUTRAL';
                    if (deltaC >= 3) desc = 'WARMER';
                    if (deltaC <= -3) desc = 'COOLER';
                    if (els.tempDescBox) els.tempDescBox.innerText = desc;
                }

                // Update temp card modal value string dynamically
                els.tempCardValue = function() {
                    var actual = current_weather.temperature;
                    var feelsNow = feelsC;
                    if (state.unit === 'f') {
                        actual = (actual * 9/5) + 32;
                        feelsNow = (feelsNow * 9/5) + 32;
                    }
                    var high = daily.temperature_2m_max[0];
                    var low = daily.temperature_2m_min[0];
                    if (state.unit === 'f') {
                        high = (high * 9/5) + 32;
                        low = (low * 9/5) + 32;
                    }
                    return `CURRENT ${Math.round(actual)}° | FEELS ${Math.round(feelsNow)}° | H ${Math.round(high)}° / L ${Math.round(low)}°`;
                };
            } catch (e) {}

            // MOON PHASE (computed locally; no external API required)
            try {
                var mpObj = computeMoonPhase(new Date());
                var mpName = mpObj.name;
                var pct = Math.round(mpObj.percent || (mpObj.illumination || (mpObj.fraction * 100)));
                if (els.moon) els.moon.innerText = mpName;
                if (els.moonDesc) {
                    els.moonDesc.innerText = `${pct}% LIT`;
                }
                // Map to Erik Flowers Weather Icons for moon phases
                var moonIconClass = 'wi wi-moon-alt-full';
                if (pct <= 3 || pct >= 97) {
                    moonIconClass = 'wi wi-moon-alt-new';
                } else if (mpName === 'WAXING CRESCENT') {
                    moonIconClass = 'wi wi-moon-alt-waxing-crescent-4';
                } else if (mpName === 'FIRST QUARTER') {
                    moonIconClass = 'wi wi-moon-alt-first-quarter';
                } else if (mpName === 'WAXING GIBBOUS') {
                    moonIconClass = 'wi wi-moon-alt-waxing-gibbous-4';
                } else if (mpName === 'FULL MOON') {
                    moonIconClass = 'wi wi-moon-alt-full';
                } else if (mpName === 'WANING GIBBOUS') {
                    moonIconClass = 'wi wi-moon-alt-waning-gibbous-4';
                } else if (mpName === 'LAST QUARTER') {
                    moonIconClass = 'wi wi-moon-alt-third-quarter';
                } else if (mpName === 'WANING CRESCENT') {
                    moonIconClass = 'wi wi-moon-alt-waning-crescent-4';
                }
                window.currentMoonIcon = moonIconClass;
                if (els && els.moonIcon) {
                    els.moonIcon.className = `${moonIconClass} text-4xl text-accent`;
                }
            } catch (e) {}
            
            // Wind
            var windRaw = current_weather.windspeed; // km/h
            var wind = windRaw;
            var windUnit = 'km/h';
            if (state.windSpeedUnit === 'mph') {
                wind = wind * 0.621371; 
                windUnit = 'mph';
            }
            els.wind.innerText = Math.round(wind);
            els.windDesc.innerText = getWindDesc(windRaw);
            document.querySelectorAll('.unit-wind').forEach(el => el.innerText = windUnit);
            
            // Wind Compass
            // Point the arrow where the wind is GOING to (Flow direction)
            var windDir = current_weather.winddirection;
            els.windCompass.style.transform = `rotate(${windDir + 180}deg)`;

            // Humidity
            var humidity = hourly.relativehumidity_2m[hIdx];
            els.humidity.innerText = humidity;
            els.humidityDesc.innerText = getHumDesc(humidity);
            els.humidityMarker.style.left = humidity + '%';

            // UV
            var uv = daily.uv_index_max[0];
            els.uv.innerText = uv;
            els.uvDesc.innerText = getUVDesc(uv);
            var uvPercent = Math.min((uv / 11) * 100, 100);
            els.uvMarker.style.left = uvPercent + '%';

            // Pressure
            var pressure = hourly.surface_pressure[hIdx];
            els.pressure.innerText = Math.round(pressure);
            els.pressDesc.innerText = getPressDesc(pressure);
            
            // Visibility
            var visKm = hourly.visibility[hIdx] / 1000; // km
            var vis = visKm;
            var visUnit = 'km';
            if (state.unit === 'f') {
                vis = vis * 0.621371;
                visUnit = 'mi';
            }
            els.visibility.innerText = vis.toFixed(1);
            els.visDesc.innerText = getVisDesc(visKm);
            document.querySelectorAll('.unit-dist').forEach(el => el.innerText = visUnit);
            
            // Visibility Bars
            // Scale: 0-20km (approx)
            // 5 bars. <2, 2-5, 5-10, 10-20, >20
            var bars = els.visBars.children;
            for(let i=0; i<bars.length; i++) {
                bars[i].classList.remove('bg-accent', 'border-current');
                bars[i].classList.add('bg-blue-200', 'border-transparent');
            }
            // Logic for active bar
            var activeBar = 0;
            if(visKm > 2) activeBar = 1;
            if(visKm > 5) activeBar = 2;
            if(visKm > 10) activeBar = 3;
            if(visKm > 20) activeBar = 4;
            
            bars[activeBar].classList.remove('bg-blue-200', 'border-transparent');
            bars[activeBar].classList.add('bg-accent', 'border-current'); // Highlight active

            // Cloud Cover
            var cloud = hourly.cloudcover[hIdx];
            els.cloud.innerText = cloud;
            els.cloudDesc.innerText = getCloudDesc(cloud);
            // Update cloud icon based on coverage (Weather Icons)
            var cloudIcon = 'wi wi-day-sunny';
            if (cloud > 20) cloudIcon = 'wi wi-day-cloudy';
            if (cloud > 60) cloudIcon = 'wi wi-cloudy';
            window.currentCloudIcon = cloudIcon;
            els.cloudIconSmall.className = `${cloudIcon} text-4xl text-accent`;

            // Precipitation
            var precipRaw = 0; // default mm
            if (hourly.precipitation && hourly.precipitation[hIdx] !== undefined) {
                precipRaw = hourly.precipitation[hIdx];
            } else {
                // fallback: sum rain + showers + snowfall (converted to mm)
                var rain = (hourly.rain && hourly.rain[hIdx] !== undefined) ? hourly.rain[hIdx] : 0;
                var showers = (hourly.showers && hourly.showers[hIdx] !== undefined) ? hourly.showers[hIdx] : 0;
                var snow = (hourly.snowfall && hourly.snowfall[hIdx] !== undefined) ? hourly.snowfall[hIdx] : 0;
                // snowfall is in cm according to Open-Meteo docs; convert to mm
                var snowMm = snow * 10;
                precipRaw = rain + showers + snowMm;
            }
            if (precipRaw === null || precipRaw === undefined || isNaN(precipRaw)) precipRaw = 0;
            var precip = precipRaw;
            var precipUnit = 'mm';
            if(state.unit === 'f') {
                 precip = precip * 0.0393701;
                 precipUnit = 'in';
            }
            els.precip.innerText = precip.toFixed(state.unit === 'f' ? 2 : 1);
            els.precipDesc.innerText = getPrecipDesc(precipRaw);
            document.querySelectorAll('.unit-precip').forEach(el => el.innerText = precipUnit);

            // Daily
            els.sunrise.innerText = formatTime(daily.sunrise[0]);
            els.sunset.innerText = formatTime(daily.sunset[0]);

            // Forecast
            els.forecast.innerHTML = '';
            // Helper to parse daily date strings (avoid timezone shifting to previous day)
            function localDayName(dateStr) {
                var parts = dateStr.split('-');
                if (parts.length === 3) {
                    var y = parseInt(parts[0], 10);
                    var m = parseInt(parts[1], 10) - 1;
                    var d = parseInt(parts[2], 10);
                    var dt = new Date(y, m, d); // local date (no UTC shift)
                    return dt.toLocaleDateString('en-US', { weekday: 'short' }).toUpperCase();
                }
                return new Date(dateStr).toLocaleDateString('en-US', { weekday: 'short' }).toUpperCase();
            }

            // Show next 3 days safely (index 1,2,3) if available
            var maxForecastDays = Math.min(4, daily.time.length); // up to index 3
            for (let i = 1; i < maxForecastDays; i++) {
                let code = daily.weathercode[i];
                let info = weatherCodeMap[code] || { icon: 'wi wi-day-sunny' };
                let min = daily.temperature_2m_min[i];
                let max = daily.temperature_2m_max[i];
                if (state.unit === 'f') {
                    min = (min * 9/5) + 32;
                    max = (max * 9/5) + 32;
                }
                let dayName = localDayName(daily.time[i]);
                
                let div = document.createElement('div');
                div.className = "weather-card interactive p-6 flex flex-col items-center justify-between gap-4 cursor-pointer group";
                div.onclick = () => showDailyDetail(i);
                
                div.innerHTML = `
                    <div class="flex items-center gap-2">
                        <i class="${info.icon} text-4xl text-accent"></i>
                        <span class="font-bold text-2xl">${dayName}</span>
                    </div>
                    <div class="font-bold text-3xl">
                        ${Math.round(max)}°<span class="opacity-50 text-xl mx-2">/</span><span class="opacity-50 text-2xl">${Math.round(min)}°</span>
                    </div>
                `;
                els.forecast.appendChild(div);
            }
        }

        function getHourlyIndex() {
            if (!state.weatherData || !state.weatherData.hourly || !state.weatherData.current_weather) return 0;
            var hourly = state.weatherData.hourly;
            var current_weather = state.weatherData.current_weather;

            var hIdx = hourly.time.findIndex(t => t === current_weather.time);
            if (hIdx === -1) {
                var currentHourStr = current_weather.time.substring(0, 13);
                hIdx = hourly.time.findIndex(time => time.startsWith(currentHourStr));
            }
            if (hIdx === -1) hIdx = 0;
            return hIdx;
        }

        function renderWindChart() {
            if (!els.modalExtra) return;
            if (!state.weatherData || !state.weatherData.hourly) {
                els.modalExtra.innerHTML = '<div class="text-sm opacity-60">NO_HOURLY_DATA</div>';
                return;
            }

            var hourly = state.weatherData.hourly;
            if (!hourly.windspeed_10m || !hourly.time) {
                els.modalExtra.innerHTML = '<div class="text-sm opacity-60">NO_WIND_SERIES_AVAILABLE</div>';
                return;
            }

            // Build a series for the *current local day* (00:00–23:00), including past hours
            var points = [];
            var labels = [];
            var times = [];
            var dirs = [];

            function formatChartHour(iso) {
                if (!iso || !iso.includes('T')) return '';
                var timePart = iso.split('T')[1] || '';
                if (state.timeFormat === '24') return timePart;
                var parts = timePart.split(':');
                var h = parseInt(parts[0], 10);
                var ampm = h >= 12 ? 'PM' : 'AM';
                h = h % 12;
                h = h ? h : 12;
                return `${h}${ampm}`; // compact label for axis
            }

            var dayPrefix = (state.weatherData.current_weather && state.weatherData.current_weather.time)
                ? state.weatherData.current_weather.time.split('T')[0]
                : null;

            var dayIndices = [];
            if (dayPrefix) {
                for (var di = 0; di < hourly.time.length; di++) {
                    if (hourly.time[di] && hourly.time[di].startsWith(dayPrefix)) dayIndices.push(di);
                }
            }

            // Fallback: if we can't find today's slice, use a rolling 24h window from current index
            if (dayIndices.length === 0) {
                var start = getHourlyIndex();
                for (var ri = start; ri < Math.min(start + 24, hourly.time.length); ri++) dayIndices.push(ri);
            }

            // Use at most 24 points (today should be exactly 24)
            dayIndices = dayIndices.slice(0, 24);

            for (var ii = 0; ii < dayIndices.length; ii++) {
                var i = dayIndices[ii];

                var ws = hourly.windspeed_10m[i]; // km/h
                if (state.windSpeedUnit === 'mph') ws = ws * 0.621371; // mph
                points.push(ws);

                var t = hourly.time[i];
                times.push(t);
                labels.push(formatChartHour(t));

                var wd = (hourly.winddirection_10m && hourly.winddirection_10m[i] !== undefined) ? hourly.winddirection_10m[i] : null;
                dirs.push(wd);
            }

            // Current time marker index (within the chart's "today" series)
            var nowIdx = -1;
            if (state.weatherData.current_weather && state.weatherData.current_weather.time) {
                var nowStr = state.weatherData.current_weather.time;
                nowIdx = times.findIndex(t => t === nowStr);
                if (nowIdx === -1) {
                    var nowPrefix = nowStr.substring(0, 13);
                    nowIdx = times.findIndex(t => t && t.startsWith(nowPrefix));
                }
            }

            var unit = state.windSpeedUnit === 'mph' ? 'mph' : 'km/h';

            els.modalExtra.innerHTML = `
                <div class="text-left w-full">
                    <div class="flex items-baseline justify-between gap-4 mb-2">
                        <div class="text-xs font-bold opacity-60 tracking-widest">TODAY_WIND_SPEED</div>
                        <div class="text-xs font-bold" style="color:#cbd5e1">${unit}</div>
                    </div>

                    <div class="relative">
                        <canvas id="wind-chart" width="720" height="220" class="w-full h-44 border-2 border-[var(--text-color)] bg-transparent"></canvas>

                        <!-- Hover Tooltip -->
                        <div id="wind-tooltip" class="hidden absolute z-30 pointer-events-none select-none bg-[var(--card-bg)] text-[var(--text-color)] border-2 border-[var(--text-color)] shadow-[4px_4px_0px_rgba(0,0,0,0.2)] px-3 py-2 text-xs w-48">
                            <div id="wind-tooltip-time" class="font-bold opacity-60 tracking-widest">--:--</div>
                            <div class="mt-2 flex items-center justify-between gap-3">
                                <div>
                                    <div class="text-[0.7rem] font-bold opacity-60">SPEED</div>
                                    <div id="wind-tooltip-speed" class="text-lg font-bold leading-none">--</div>
                                </div>
                                <div class="relative w-12 h-12 border-2 border-current rounded-full flex items-center justify-center">
                                    <div class="absolute top-[2px] left-1/2 -translate-x-1/2 text-[0.55rem] font-bold bg-[var(--card-bg)] px-0.5 leading-none">N</div>
                                    <div class="absolute bottom-[2px] left-1/2 -translate-x-1/2 text-[0.55rem] font-bold bg-[var(--card-bg)] px-0.5 leading-none">S</div>
                                    <div class="absolute left-[2px] top-1/2 -translate-y-1/2 text-[0.55rem] font-bold bg-[var(--card-bg)] px-0.5 leading-none">W</div>
                                    <div class="absolute right-[2px] top-1/2 -translate-y-1/2 text-[0.55rem] font-bold bg-[var(--card-bg)] px-0.5 leading-none">E</div>
                                    <svg id="wind-tooltip-arrow" viewBox="0 0 24 24" class="w-6 h-6 text-accent" style="transform-origin: 50% 50%;">
                                        <path d="M12 3L12 21M12 3L7 10M12 3L17 10" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                                    </svg>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="mt-2 text-[0.75rem] opacity-60 leading-snug">
                        HOVER_OVER_GRAPH_TO_HIGHLIGHT
                    </div>
                </div>
            `;

            var canvas = document.getElementById('wind-chart');
            if (!canvas) return;
            var ctx = canvas.getContext('2d');
            if (!ctx) return;

            // High-DPI handling
            var dpr = window.devicePixelRatio || 1;
            var cssW = canvas.clientWidth;
            var cssH = canvas.clientHeight;
            canvas.width = Math.floor(cssW * dpr);
            canvas.height = Math.floor(cssH * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            var w = cssW;
            var h = cssH;
            // Padding tuned so the plot doesn't feel horizontally squished
            var padL = 18;
            var padR = 10;
            var padT = 10;
            var padB = 26;

            var minV = Math.min.apply(null, points);
            var maxV = Math.max.apply(null, points);
            if (minV === maxV) {
                minV = Math.max(0, minV - 5);
                maxV = maxV + 5;
            }
            // Add a little headroom
            var range = maxV - minV;
            minV -= range * 0.1;
            maxV += range * 0.1;

            function xScale(i) {
                if (points.length <= 1) return padL;
                return padL + (i * (w - padL - padR) / (points.length - 1));
            }
            function yScale(v) {
                return padT + (maxV - v) * (h - padT - padB) / (maxV - minV);
            }

            // Background (explicit fill to avoid transparent canvas tint)
            var bgCol = (getComputedStyle(document.documentElement).getPropertyValue('--bg-color') || '#ffffff').trim();
            ctx.clearRect(0, 0, w, h);
            ctx.fillStyle = bgCol;
            ctx.fillRect(0, 0, w, h);

            // Grid
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--card-border') || 'rgba(0,0,0,0.15)';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            var gridLines = 4;
            for (var g = 0; g <= gridLines; g++) {
                var y = padT + g * (h - padT - padB) / gridLines;
                ctx.beginPath();
                ctx.moveTo(padL, y);
                ctx.lineTo(w - padR, y);
                ctx.stroke();
            }
            ctx.setLineDash([]);

            // Axes
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-color') || '#111';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padL, padT);
            ctx.lineTo(padL, h - padB);
            ctx.lineTo(w - padR, h - padB);
            ctx.stroke();

            // Helper to draw base chart (and optional hover highlight)
            var accent = (getComputedStyle(document.documentElement).getPropertyValue('--accent-color') || '#f97316').trim();
            var textCol = (getComputedStyle(document.documentElement).getPropertyValue('--text-color') || '#111').trim();
            var gridCol = (getComputedStyle(document.documentElement).getPropertyValue('--card-border') || 'rgba(0,0,0,0.15)').trim();

            // Wind chart palette: light gray line/points (requested)
            var windLineCol = '#cbd5e1'; // slate-300
            var windPointCol = '#cbd5e1';
            var windHoverFill = '#e2e8f0'; // slate-200

            function draw(hoverIdx) {
                // Background (explicit fill to avoid unexpected canvas tint)
                var bgCol = (getComputedStyle(document.documentElement).getPropertyValue('--bg-color') || '#ffffff').trim();
                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = bgCol;
                ctx.fillRect(0, 0, w, h);

                // Grid
                ctx.strokeStyle = gridCol;
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                var gridLines = 4;
                for (var g = 0; g <= gridLines; g++) {
                    var gy = padT + g * (h - padT - padB) / gridLines;
                    ctx.beginPath();
                    ctx.moveTo(padL, gy);
                    ctx.lineTo(w - padR, gy);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                // Axes
                ctx.strokeStyle = textCol;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padL, padT);
                ctx.lineTo(padL, h - padB);
                ctx.lineTo(w - padR, h - padB);
                ctx.stroke();

                // Line
                ctx.strokeStyle = windLineCol;
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (var p = 0; p < points.length; p++) {
                    var x = xScale(p);
                    var y = yScale(points[p]);
                    if (p === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Points
                ctx.fillStyle = windPointCol;
                for (var q = 0; q < points.length; q++) {
                    var px = xScale(q);
                    var py = yScale(points[q]);
                    ctx.beginPath();
                    ctx.arc(px, py, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // NOW marker (current hour)
                if (nowIdx !== null && nowIdx !== undefined && nowIdx >= 0 && nowIdx < points.length) {
                    var nx = xScale(nowIdx);
                    ctx.save();
                    ctx.strokeStyle = textCol;
                    ctx.globalAlpha = 0.55;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6, 6]);
                    ctx.beginPath();
                    ctx.moveTo(nx, padT);
                    ctx.lineTo(nx, h - padB);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // No text label (marker line only)
                    ctx.restore();
                }

                // Hover highlight
                if (hoverIdx !== null && hoverIdx !== undefined) {
                    var hx = xScale(hoverIdx);
                    var hy = yScale(points[hoverIdx]);

                    // Vertical guide
                    ctx.strokeStyle = textCol;
                    ctx.globalAlpha = 0.35;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(hx, padT);
                    ctx.lineTo(hx, h - padB);
                    ctx.stroke();
                    ctx.globalAlpha = 1;

                    // Highlight point (draw in device pixels to guarantee a true circle)
                    ctx.save();
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    var hxDev = hx * dpr;
                    var hyDev = hy * dpr;

                    ctx.fillStyle = windPointCol;
                    ctx.beginPath();
                    ctx.arc(hxDev, hyDev, 6 * dpr, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = textCol;
                    ctx.lineWidth = 2 * dpr;
                    ctx.beginPath();
                    ctx.arc(hxDev, hyDev, 6 * dpr, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }

                // Y labels (min/max)
                ctx.fillStyle = textCol;
                ctx.font = 'bold 10px "Space Mono", monospace';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText(Math.round(maxV) + '', 6, padT + 6);
                ctx.fillText(Math.round(minV) + '', 6, h - padB - 6);

                // X labels (tuned for 24 points)
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.font = 'bold 9px "Space Mono", monospace';
                var step = (state.timeFormat === '24') ? 3 : 4;
                for (var tIdx = 0; tIdx < labels.length; tIdx += step) {
                    var lx = xScale(tIdx);
                    var txt = labels[tIdx] || '';
                    ctx.fillText(txt, lx, h - padB + 4);
                }
            }

            // Initial draw
            draw(null);

            // Hover interaction (with tooltip + mini compass)
            var tooltip = document.getElementById('wind-tooltip');
            var ttTime = document.getElementById('wind-tooltip-time');
            var ttSpeed = document.getElementById('wind-tooltip-speed');
            var ttArrow = document.getElementById('wind-tooltip-arrow');

            function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

            function indexFromX(x) {
                var rel = (x - padL) / (w - padL - padR);
                var idx = Math.round(rel * (points.length - 1));
                return clamp(idx, 0, points.length - 1);
            }

            function placeTooltip(localX, localY) {
                if (!tooltip) return;
                // Tooltip size (CSS width) ~ 12rem (192px)
                var tw = 192;
                var th = 78;
                var x = localX + 12;
                var y = localY + 12;
                if (x + tw > w - 4) x = localX - tw - 12;
                if (y + th > h - 4) y = localY - th - 12;
                tooltip.style.left = x + 'px';
                tooltip.style.top = y + 'px';
            }

            function onMove(e) {
                var rect = canvas.getBoundingClientRect();
                var x = e.clientX - rect.left;
                var y = e.clientY - rect.top;
                var idx = indexFromX(x);

                draw(idx);

                if (tooltip) {
                    tooltip.classList.remove('hidden');
                    placeTooltip(x, y);
                }

                if (ttTime) ttTime.innerText = formatTime(times[idx]);
                if (ttSpeed) ttSpeed.innerText = (points[idx].toFixed(1)) + ' ' + unit;

                // Direction: keep consistent with main compass (flow direction)
                var dir = dirs[idx];
                if (ttArrow && dir !== null && dir !== undefined) {
                    ttArrow.style.transform = `rotate(${dir + 180}deg)`;
                }
            }

            function onLeave() {
                draw(null);
                if (tooltip) tooltip.classList.add('hidden');
            }

            // Remove previous listeners if any (avoid duplicates when reopening modal)
            if (canvas._mwMove) canvas.removeEventListener('mousemove', canvas._mwMove);
            if (canvas._mwLeave) canvas.removeEventListener('mouseleave', canvas._mwLeave);

            canvas._mwMove = onMove;
            canvas._mwLeave = onLeave;
            canvas.addEventListener('mousemove', onMove);
            canvas.addEventListener('mouseleave', onLeave);
        }

        function renderHumidityChart() {
            if (!els.modalExtra) return;
            if (!state.weatherData || !state.weatherData.hourly) {
                els.modalExtra.innerHTML = '<div class="text-sm opacity-60">NO_HOURLY_DATA</div>';
                return;
            }

            var hourly = state.weatherData.hourly;
            if (!hourly.relativehumidity_2m || !hourly.time) {
                els.modalExtra.innerHTML = '<div class="text-sm opacity-60">NO_HUMIDITY_SERIES_AVAILABLE</div>';
                return;
            }

            // Build a series for the *current local day* (00:00–23:00), including past hours
            var points = [];
            var labels = [];
            var times = [];

            function formatChartHour(iso) {
                if (!iso || !iso.includes('T')) return '';
                var timePart = iso.split('T')[1] || '';
                if (state.timeFormat === '24') return timePart;
                var parts = timePart.split(':');
                var h = parseInt(parts[0], 10);
                var ampm = h >= 12 ? 'PM' : 'AM';
                h = h % 12;
                h = h ? h : 12;
                return `${h}${ampm}`;
            }

            var dayPrefix = (state.weatherData.current_weather && state.weatherData.current_weather.time)
                ? state.weatherData.current_weather.time.split('T')[0]
                : null;

            var dayIndices = [];
            if (dayPrefix) {
                for (var di = 0; di < hourly.time.length; di++) {
                    if (hourly.time[di] && hourly.time[di].startsWith(dayPrefix)) dayIndices.push(di);
                }
            }

            // Fallback: rolling 24h from current index
            if (dayIndices.length === 0) {
                var start = getHourlyIndex();
                for (var ri = start; ri < Math.min(start + 24, hourly.time.length); ri++) dayIndices.push(ri);
            }

            dayIndices = dayIndices.slice(0, 24);

            for (var ii = 0; ii < dayIndices.length; ii++) {
                var i = dayIndices[ii];
                var hVal = hourly.relativehumidity_2m[i];
                points.push(hVal);
                var t = hourly.time[i];
                times.push(t);
                labels.push(formatChartHour(t));
            }

            // Current time marker index
            var nowIdx = -1;
            if (state.weatherData.current_weather && state.weatherData.current_weather.time) {
                var nowStr = state.weatherData.current_weather.time;
                nowIdx = times.findIndex(t => t === nowStr);
                if (nowIdx === -1) {
                    var nowPrefix = nowStr.substring(0, 13);
                    nowIdx = times.findIndex(t => t && t.startsWith(nowPrefix));
                }
            }

            els.modalExtra.innerHTML = `
                <div class="text-left w-full">
                    <div class="flex items-baseline justify-between gap-4 mb-2">
                        <div class="text-xs font-bold opacity-60 tracking-widest">TODAY_HUMIDITY</div>
                        <div class="text-xs font-bold" style="color: rgb(29, 78, 216)">%</div>
                    </div>

                    <div class="relative">
                        <canvas id="humidity-chart" width="720" height="220" class="w-full h-44 border-2 border-[var(--text-color)] bg-transparent"></canvas>

                        <!-- Hover Tooltip -->
                        <div id="humidity-tooltip" class="hidden absolute z-30 pointer-events-none select-none bg-[var(--card-bg)] text-[var(--text-color)] border-2 border-[var(--text-color)] shadow-[4px_4px_0px_rgba(0,0,0,0.2)] px-3 py-2 text-xs w-44">
                            <div id="humidity-tooltip-time" class="font-bold opacity-60 tracking-widest">--:--</div>
                            <div class="mt-2">
                                <div class="text-[0.7rem] font-bold opacity-60">HUMIDITY</div>
                                <div id="humidity-tooltip-val" class="text-lg font-bold leading-none" style="color: rgb(29, 78, 216)">--%</div>
                            </div>
                        </div>
                    </div>

                    <div class="mt-2 text-[0.75rem] opacity-60 leading-snug">
                        HOVER_OVER_GRAPH_TO_HIGHLIGHT
                    </div>
                </div>
            `;

            var canvas = document.getElementById('humidity-chart');
            if (!canvas) return;
            var ctx = canvas.getContext('2d');
            if (!ctx) return;

            // High-DPI handling
            var dpr = window.devicePixelRatio || 1;
            var cssW = canvas.clientWidth;
            var cssH = canvas.clientHeight;
            canvas.width = Math.floor(cssW * dpr);
            canvas.height = Math.floor(cssH * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            var w = cssW;
            var h = cssH;
            var padL = 18;
            var padR = 10;
            var padT = 10;
            var padB = 26;

            // Fixed scale for humidity
            var minV = 0;
            var maxV = 100;

            function xScale(i) {
                if (points.length <= 1) return padL;
                return padL + (i * (w - padL - padR) / (points.length - 1));
            }
            function yScale(v) {
                return padT + (maxV - v) * (h - padT - padB) / (maxV - minV);
            }

            var textCol = (getComputedStyle(document.documentElement).getPropertyValue('--text-color') || '#111').trim();
            var gridCol = (getComputedStyle(document.documentElement).getPropertyValue('--card-border') || 'rgba(0,0,0,0.15)').trim();

            // Humidity palette
            var lineCol = 'rgba(29, 78, 216, 0.9)';
            var pointCol = 'rgba(29, 78, 216, 0.95)';

            function fillHumidityBackground() {
                // Base theme background
                var bgCol = (getComputedStyle(document.documentElement).getPropertyValue('--bg-color') || '#ffffff').trim();
                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = bgCol;
                ctx.fillRect(0, 0, w, h);

                // Subtle vertical gradient overlay (dark blue top -> light blue bottom)
                var grad = ctx.createLinearGradient(0, 0, 0, h);
                grad.addColorStop(0, 'rgba(30, 64, 175, 0.22)');
                grad.addColorStop(1, 'rgba(191, 219, 254, 0.14)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, w, h);
            }

            function draw(hoverIdx) {
                fillHumidityBackground();

                // Grid
                ctx.strokeStyle = gridCol;
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                var gridLines = 4;
                for (var g = 0; g <= gridLines; g++) {
                    var gy = padT + g * (h - padT - padB) / gridLines;
                    ctx.beginPath();
                    ctx.moveTo(padL, gy);
                    ctx.lineTo(w - padR, gy);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                // Axes
                ctx.strokeStyle = textCol;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padL, padT);
                ctx.lineTo(padL, h - padB);
                ctx.lineTo(w - padR, h - padB);
                ctx.stroke();

                // Line
                ctx.strokeStyle = lineCol;
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (var p = 0; p < points.length; p++) {
                    var x = xScale(p);
                    var y = yScale(points[p]);
                    if (p === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Points
                ctx.fillStyle = pointCol;
                for (var q = 0; q < points.length; q++) {
                    var px = xScale(q);
                    var py = yScale(points[q]);
                    ctx.beginPath();
                    ctx.arc(px, py, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Current hour marker
                if (nowIdx !== null && nowIdx !== undefined && nowIdx >= 0 && nowIdx < points.length) {
                    var nx = xScale(nowIdx);
                    ctx.save();
                    ctx.strokeStyle = textCol;
                    ctx.globalAlpha = 0.55;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6, 6]);
                    ctx.beginPath();
                    ctx.moveTo(nx, padT);
                    ctx.lineTo(nx, h - padB);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.restore();
                }

                // Hover highlight
                if (hoverIdx !== null && hoverIdx !== undefined) {
                    var hx = xScale(hoverIdx);
                    var hy = yScale(points[hoverIdx]);

                    ctx.strokeStyle = textCol;
                    ctx.globalAlpha = 0.35;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(hx, padT);
                    ctx.lineTo(hx, h - padB);
                    ctx.stroke();
                    ctx.globalAlpha = 1;

                    ctx.fillStyle = pointCol;
                    ctx.beginPath();
                    ctx.arc(hx, hy, 6, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = textCol;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(hx, hy, 6, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Y labels (0 / 100)
                ctx.fillStyle = textCol;
                ctx.font = 'bold 10px "Space Mono", monospace';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText('100', 6, padT + 6);
                ctx.fillText('0', 6, h - padB - 6);

                // X labels
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.font = 'bold 9px "Space Mono", monospace';
                var step = (state.timeFormat === '24') ? 3 : 4;
                for (var tIdx = 0; tIdx < labels.length; tIdx += step) {
                    var lx = xScale(tIdx);
                    var txt = labels[tIdx] || '';
                    ctx.fillText(txt, lx, h - padB + 4);
                }
            }

            draw(null);

            var tooltip = document.getElementById('humidity-tooltip');
            var ttTime = document.getElementById('humidity-tooltip-time');
            var ttVal = document.getElementById('humidity-tooltip-val');

            function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
            function indexFromX(x) {
                var rel = (x - padL) / (w - padL - padR);
                var idx = Math.round(rel * (points.length - 1));
                return clamp(idx, 0, points.length - 1);
            }
            function placeTooltip(localX, localY) {
                if (!tooltip) return;
                var tw = 176;
                var th = 62;
                var x = localX + 12;
                var y = localY + 12;
                if (x + tw > w - 4) x = localX - tw - 12;
                if (y + th > h - 4) y = localY - th - 12;
                tooltip.style.left = x + 'px';
                tooltip.style.top = y + 'px';
            }

            function onMove(e) {
                var rect = canvas.getBoundingClientRect();
                var x = e.clientX - rect.left;
                var y = e.clientY - rect.top;
                var idx = indexFromX(x);

                draw(idx);

                if (tooltip) {
                    tooltip.classList.remove('hidden');
                    placeTooltip(x, y);
                }
                if (ttTime) ttTime.innerText = formatTime(times[idx]);
                if (ttVal) ttVal.innerText = Math.round(points[idx]) + '%';
            }

            function onLeave() {
                draw(null);
                if (tooltip) tooltip.classList.add('hidden');
            }

            if (canvas._mwHumMove) canvas.removeEventListener('mousemove', canvas._mwHumMove);
            if (canvas._mwHumLeave) canvas.removeEventListener('mouseleave', canvas._mwHumLeave);
            canvas._mwHumMove = onMove;
            canvas._mwHumLeave = onLeave;
            canvas.addEventListener('mousemove', onMove);
            canvas.addEventListener('mouseleave', onLeave);
        }

        function renderUVChart() {
            if (!els.modalExtra) return;
            if (!state.weatherData || !state.weatherData.hourly) {
                els.modalExtra.innerHTML = '<div class="text-sm opacity-60">NO_HOURLY_DATA</div>';
                return;
            }

            var hourly = state.weatherData.hourly;
            if (!hourly.uv_index || !hourly.time) {
                els.modalExtra.innerHTML = '<div class="text-sm opacity-60">NO_UV_SERIES_AVAILABLE</div>';
                return;
            }

            // Build a series for the *current local day* (00:00–23:00), including past hours
            var points = [];
            var labels = [];
            var times = [];

            function formatChartHour(iso) {
                if (!iso || !iso.includes('T')) return '';
                var timePart = iso.split('T')[1] || '';
                if (state.timeFormat === '24') return timePart;
                var parts = timePart.split(':');
                var h = parseInt(parts[0], 10);
                var ampm = h >= 12 ? 'PM' : 'AM';
                h = h % 12;
                h = h ? h : 12;
                return `${h}${ampm}`;
            }

            var dayPrefix = (state.weatherData.current_weather && state.weatherData.current_weather.time)
                ? state.weatherData.current_weather.time.split('T')[0]
                : null;

            var dayIndices = [];
            if (dayPrefix) {
                for (var di = 0; di < hourly.time.length; di++) {
                    if (hourly.time[di] && hourly.time[di].startsWith(dayPrefix)) dayIndices.push(di);
                }
            }

            // Fallback: rolling 24h from current index
            if (dayIndices.length === 0) {
                var start = getHourlyIndex();
                for (var ri = start; ri < Math.min(start + 24, hourly.time.length); ri++) dayIndices.push(ri);
            }

            dayIndices = dayIndices.slice(0, 24);

            for (var ii = 0; ii < dayIndices.length; ii++) {
                var i = dayIndices[ii];
                var uvVal = hourly.uv_index[i];
                points.push(uvVal);
                var t = hourly.time[i];
                times.push(t);
                labels.push(formatChartHour(t));
            }

            // Current time marker index
            var nowIdx = -1;
            if (state.weatherData.current_weather && state.weatherData.current_weather.time) {
                var nowStr = state.weatherData.current_weather.time;
                nowIdx = times.findIndex(t => t === nowStr);
                if (nowIdx === -1) {
                    var nowPrefix = nowStr.substring(0, 13);
                    nowIdx = times.findIndex(t => t && t.startsWith(nowPrefix));
                }
            }

            els.modalExtra.innerHTML = `
                <div class="text-left w-full">
                    <div class="flex items-baseline justify-between gap-4 mb-2">
                        <div class="text-xs font-bold opacity-60 tracking-widest">TODAY_UV_INDEX</div>
                        <div class="text-xs font-bold" style="color:#a855f7">UV</div>
                    </div>

                    <div class="relative">
                        <canvas id="uv-chart" width="720" height="220" class="w-full h-44 border-2 border-[var(--text-color)] bg-transparent"></canvas>

                        <!-- Hover Tooltip -->
                        <div id="uv-tooltip" class="hidden absolute z-30 pointer-events-none select-none bg-[var(--card-bg)] text-[var(--text-color)] border-2 border-[var(--text-color)] shadow-[4px_4px_0px_rgba(0,0,0,0.2)] px-3 py-2 text-xs w-44">
                            <div id="uv-tooltip-time" class="font-bold opacity-60 tracking-widest">--:--</div>
                            <div class="mt-2">
                                <div class="text-[0.7rem] font-bold opacity-60">UV INDEX</div>
                                <div id="uv-tooltip-val" class="text-lg font-bold leading-none" style="color:#a855f7">--</div>
                            </div>
                        </div>
                    </div>

                    <div class="mt-2 text-[0.75rem] opacity-60 leading-snug">
                        HOVER_OVER_GRAPH_TO_HIGHLIGHT
                    </div>
                </div>
            `;

            var canvas = document.getElementById('uv-chart');
            if (!canvas) return;
            var ctx = canvas.getContext('2d');
            if (!ctx) return;

            // High-DPI handling
            var dpr = window.devicePixelRatio || 1;
            var cssW = canvas.clientWidth;
            var cssH = canvas.clientHeight;
            canvas.width = Math.floor(cssW * dpr);
            canvas.height = Math.floor(cssH * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            var w = cssW;
            var h = cssH;
            var padL = 18;
            var padR = 10;
            var padT = 10;
            var padB = 26;

            // Fixed UV scale (0–11)
            var minV = 0;
            var maxV = 11;

            function xScale(i) {
                if (points.length <= 1) return padL;
                return padL + (i * (w - padL - padR) / (points.length - 1));
            }
            function yScale(v) {
                return padT + (maxV - v) * (h - padT - padB) / (maxV - minV);
            }

            var textCol = (getComputedStyle(document.documentElement).getPropertyValue('--text-color') || '#111').trim();
            var gridCol = (getComputedStyle(document.documentElement).getPropertyValue('--card-border') || 'rgba(0,0,0,0.15)').trim();

            // UV palette
            var lineCol = 'rgba(147, 51, 234, 0.9)';
            var pointCol = 'rgba(147, 51, 234, 0.95)';

            function fillUVBackground() {
                // Base theme background
                var bgCol = (getComputedStyle(document.documentElement).getPropertyValue('--bg-color') || '#ffffff').trim();
                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = bgCol;
                ctx.fillRect(0, 0, w, h);

                // Subtle vertical gradient overlay (dark purple top -> light purple bottom)
                var grad = ctx.createLinearGradient(0, 0, 0, h);
                grad.addColorStop(0, 'rgba(88, 28, 135, 0.22)');
                grad.addColorStop(1, 'rgba(233, 213, 255, 0.14)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, w, h);
            }

            function draw(hoverIdx) {
                fillUVBackground();

                // Grid
                ctx.strokeStyle = gridCol;
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                var gridLines = 4;
                for (var g = 0; g <= gridLines; g++) {
                    var gy = padT + g * (h - padT - padB) / gridLines;
                    ctx.beginPath();
                    ctx.moveTo(padL, gy);
                    ctx.lineTo(w - padR, gy);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                // Axes
                ctx.strokeStyle = textCol;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padL, padT);
                ctx.lineTo(padL, h - padB);
                ctx.lineTo(w - padR, h - padB);
                ctx.stroke();

                // Line
                ctx.strokeStyle = lineCol;
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (var p = 0; p < points.length; p++) {
                    var x = xScale(p);
                    var y = yScale(points[p]);
                    if (p === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Points
                ctx.fillStyle = pointCol;
                for (var q = 0; q < points.length; q++) {
                    var px = xScale(q);
                    var py = yScale(points[q]);
                    ctx.beginPath();
                    ctx.arc(px, py, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Current hour marker
                if (nowIdx !== null && nowIdx !== undefined && nowIdx >= 0 && nowIdx < points.length) {
                    var nx = xScale(nowIdx);
                    ctx.save();
                    ctx.strokeStyle = textCol;
                    ctx.globalAlpha = 0.55;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6, 6]);
                    ctx.beginPath();
                    ctx.moveTo(nx, padT);
                    ctx.lineTo(nx, h - padB);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.restore();
                }

                // Hover highlight
                if (hoverIdx !== null && hoverIdx !== undefined) {
                    var hx = xScale(hoverIdx);
                    var hy = yScale(points[hoverIdx]);

                    ctx.strokeStyle = textCol;
                    ctx.globalAlpha = 0.35;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(hx, padT);
                    ctx.lineTo(hx, h - padB);
                    ctx.stroke();
                    ctx.globalAlpha = 1;

                    ctx.fillStyle = pointCol;
                    ctx.beginPath();
                    ctx.arc(hx, hy, 6, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = textCol;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(hx, hy, 6, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Y labels (0 / 11)
                ctx.fillStyle = textCol;
                ctx.font = 'bold 10px "Space Mono", monospace';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText('11', 6, padT + 6);
                ctx.fillText('0', 6, h - padB - 6);

                // X labels
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.font = 'bold 9px "Space Mono", monospace';
                var step = (state.timeFormat === '24') ? 3 : 4;
                for (var tIdx = 0; tIdx < labels.length; tIdx += step) {
                    var lx = xScale(tIdx);
                    var txt = labels[tIdx] || '';
                    ctx.fillText(txt, lx, h - padB + 4);
                }
            }

            draw(null);

            var tooltip = document.getElementById('uv-tooltip');
            var ttTime = document.getElementById('uv-tooltip-time');
            var ttVal = document.getElementById('uv-tooltip-val');

            function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
            function indexFromX(x) {
                var rel = (x - padL) / (w - padL - padR);
                var idx = Math.round(rel * (points.length - 1));
                return clamp(idx, 0, points.length - 1);
            }
            function placeTooltip(localX, localY) {
                if (!tooltip) return;
                var tw = 176;
                var th = 62;
                var x = localX + 12;
                var y = localY + 12;
                if (x + tw > w - 4) x = localX - tw - 12;
                if (y + th > h - 4) y = localY - th - 12;
                tooltip.style.left = x + 'px';
                tooltip.style.top = y + 'px';
            }

            function onMove(e) {
                var rect = canvas.getBoundingClientRect();
                var x = e.clientX - rect.left;
                var y = e.clientY - rect.top;
                var idx = indexFromX(x);

                draw(idx);

                if (tooltip) {
                    tooltip.classList.remove('hidden');
                    placeTooltip(x, y);
                }
                if (ttTime) ttTime.innerText = formatTime(times[idx]);
                if (ttVal) ttVal.innerText = (Math.round(points[idx] * 10) / 10).toFixed(1);
            }

            function onLeave() {
                draw(null);
                if (tooltip) tooltip.classList.add('hidden');
            }

            if (canvas._mwUvMove) canvas.removeEventListener('mousemove', canvas._mwUvMove);
            if (canvas._mwUvLeave) canvas.removeEventListener('mouseleave', canvas._mwUvLeave);
            canvas._mwUvMove = onMove;
            canvas._mwUvLeave = onLeave;
            canvas.addEventListener('mousemove', onMove);
            canvas.addEventListener('mouseleave', onLeave);
        }

        function renderVisibilityChart() {
            if (!els.modalExtra) return;
            if (!state.weatherData || !state.weatherData.hourly) {
                els.modalExtra.innerHTML = '<div class="text-sm opacity-60">NO_HOURLY_DATA</div>';
                return;
            }

            var hourly = state.weatherData.hourly;
            if (!hourly.visibility || !hourly.time) {
                els.modalExtra.innerHTML = '<div class="text-sm opacity-60">NO_VISIBILITY_SERIES_AVAILABLE</div>';
                return;
            }

            // Build a series for the *current local day* (00:00–23:00), including past hours
            var points = [];
            var labels = [];
            var times = [];

            var unit = (state.unit === 'f') ? 'mi' : 'km';

            function formatChartHour(iso) {
                if (!iso || !iso.includes('T')) return '';
                var timePart = iso.split('T')[1] || '';
                if (state.timeFormat === '24') return timePart;
                var parts = timePart.split(':');
                var h = parseInt(parts[0], 10);
                var ampm = h >= 12 ? 'PM' : 'AM';
                h = h % 12;
                h = h ? h : 12;
                return `${h}${ampm}`;
            }

            var dayPrefix = (state.weatherData.current_weather && state.weatherData.current_weather.time)
                ? state.weatherData.current_weather.time.split('T')[0]
                : null;

            var dayIndices = [];
            if (dayPrefix) {
                for (var di = 0; di < hourly.time.length; di++) {
                    if (hourly.time[di] && hourly.time[di].startsWith(dayPrefix)) dayIndices.push(di);
                }
            }

            // Fallback: rolling 24h from current index
            if (dayIndices.length === 0) {
                var start = getHourlyIndex();
                for (var ri = start; ri < Math.min(start + 24, hourly.time.length); ri++) dayIndices.push(ri);
            }

            dayIndices = dayIndices.slice(0, 24);

            for (var ii = 0; ii < dayIndices.length; ii++) {
                var i = dayIndices[ii];
                var meters = hourly.visibility[i];
                var km = (meters || 0) / 1000;
                var v = km;
                if (state.unit === 'f') v = km * 0.621371;
                points.push(v);

                var t = hourly.time[i];
                times.push(t);
                labels.push(formatChartHour(t));
            }

            // Current time marker index
            var nowIdx = -1;
            if (state.weatherData.current_weather && state.weatherData.current_weather.time) {
                var nowStr = state.weatherData.current_weather.time;
                nowIdx = times.findIndex(t => t === nowStr);
                if (nowIdx === -1) {
                    var nowPrefix = nowStr.substring(0, 13);
                    nowIdx = times.findIndex(t => t && t.startsWith(nowPrefix));
                }
            }

            els.modalExtra.innerHTML = `
                <div class="text-left w-full">
                    <div class="flex items-baseline justify-between gap-4 mb-2">
                        <div class="text-xs font-bold opacity-60 tracking-widest">TODAY_VISIBILITY</div>
                        <div class="text-xs font-bold" style="color: rgb(96, 165, 250)">${unit}</div>
                    </div>

                    <div class="relative">
                        <canvas id="visibility-chart" width="720" height="220" class="w-full h-44 border-2 border-[var(--text-color)] bg-transparent"></canvas>

                        <!-- Hover Tooltip -->
                        <div id="visibility-tooltip" class="hidden absolute z-30 pointer-events-none select-none bg-[var(--card-bg)] text-[var(--text-color)] border-2 border-[var(--text-color)] shadow-[4px_4px_0px_rgba(0,0,0,0.2)] px-3 py-2 text-xs w-48">
                            <div id="visibility-tooltip-time" class="font-bold opacity-60 tracking-widest">--:--</div>
                            <div class="mt-2">
                                <div class="text-[0.7rem] font-bold opacity-60">VISIBILITY</div>
                                <div id="visibility-tooltip-val" class="text-lg font-bold leading-none" style="color: rgb(96, 165, 250)">--</div>
                            </div>
                        </div>
                    </div>

                    <div class="mt-2 text-[0.75rem] opacity-60 leading-snug">
                        HOVER_OVER_GRAPH_TO_HIGHLIGHT
                    </div>
                </div>
            `;

            var canvas = document.getElementById('visibility-chart');
            if (!canvas) return;
            var ctx = canvas.getContext('2d');
            if (!ctx) return;

            // High-DPI handling
            var dpr = window.devicePixelRatio || 1;
            var cssW = canvas.clientWidth;
            var cssH = canvas.clientHeight;
            canvas.width = Math.floor(cssW * dpr);
            canvas.height = Math.floor(cssH * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            var w = cssW;
            var h = cssH;
            var padL = 18;
            var padR = 10;
            var padT = 10;
            var padB = 26;

            var minV = Math.min.apply(null, points);
            var maxV = Math.max.apply(null, points);
            if (minV === maxV) {
                minV = Math.max(0, minV - 1);
                maxV = maxV + 1;
            }
            var range = maxV - minV;
            minV -= range * 0.1;
            maxV += range * 0.1;
            if (minV < 0) minV = 0;

            function xScale(i) {
                if (points.length <= 1) return padL;
                return padL + (i * (w - padL - padR) / (points.length - 1));
            }
            function yScale(v) {
                return padT + (maxV - v) * (h - padT - padB) / (maxV - minV);
            }

            var textCol = (getComputedStyle(document.documentElement).getPropertyValue('--text-color') || '#111').trim();
            var gridCol = (getComputedStyle(document.documentElement).getPropertyValue('--card-border') || 'rgba(0,0,0,0.15)').trim();

            // Visibility palette
            var lineCol = 'rgba(96, 165, 250, 0.9)';
            var pointCol = 'rgba(96, 165, 250, 0.95)';

            function fillVisBackground() {
                // Base theme background
                var bgCol = (getComputedStyle(document.documentElement).getPropertyValue('--bg-color') || '#ffffff').trim();
                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = bgCol;
                ctx.fillRect(0, 0, w, h);

                // Subtle vertical gradient overlay (light gray top -> light blue bottom)
                var grad = ctx.createLinearGradient(0, 0, 0, h);
                grad.addColorStop(0, 'rgba(203, 213, 225, 0.18)');
                grad.addColorStop(1, 'rgba(191, 219, 254, 0.14)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, w, h);
            }

            function draw(hoverIdx) {
                fillVisBackground();

                // Grid
                ctx.strokeStyle = gridCol;
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                var gridLines = 4;
                for (var g = 0; g <= gridLines; g++) {
                    var gy = padT + g * (h - padT - padB) / gridLines;
                    ctx.beginPath();
                    ctx.moveTo(padL, gy);
                    ctx.lineTo(w - padR, gy);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                // Axes
                ctx.strokeStyle = textCol;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padL, padT);
                ctx.lineTo(padL, h - padB);
                ctx.lineTo(w - padR, h - padB);
                ctx.stroke();

                // Line
                ctx.strokeStyle = lineCol;
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (var p = 0; p < points.length; p++) {
                    var x = xScale(p);
                    var y = yScale(points[p]);
                    if (p === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Points
                ctx.fillStyle = pointCol;
                for (var q = 0; q < points.length; q++) {
                    var px = xScale(q);
                    var py = yScale(points[q]);
                    ctx.beginPath();
                    ctx.arc(px, py, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Current hour marker
                if (nowIdx !== null && nowIdx !== undefined && nowIdx >= 0 && nowIdx < points.length) {
                    var nx = xScale(nowIdx);
                    ctx.save();
                    ctx.strokeStyle = textCol;
                    ctx.globalAlpha = 0.55;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6, 6]);
                    ctx.beginPath();
                    ctx.moveTo(nx, padT);
                    ctx.lineTo(nx, h - padB);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.restore();
                }

                // Hover highlight
                if (hoverIdx !== null && hoverIdx !== undefined) {
                    var hx = xScale(hoverIdx);
                    var hy = yScale(points[hoverIdx]);

                    ctx.strokeStyle = textCol;
                    ctx.globalAlpha = 0.35;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(hx, padT);
                    ctx.lineTo(hx, h - padB);
                    ctx.stroke();
                    ctx.globalAlpha = 1;

                    ctx.fillStyle = pointCol;
                    ctx.beginPath();
                    ctx.arc(hx, hy, 6, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = textCol;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(hx, hy, 6, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Y labels (min/max)
                ctx.fillStyle = textCol;
                ctx.font = 'bold 10px "Space Mono", monospace';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText((Math.round(maxV * 10) / 10).toFixed(1), 6, padT + 6);
                ctx.fillText((Math.round(minV * 10) / 10).toFixed(1), 6, h - padB - 6);

                // X labels
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.font = 'bold 9px "Space Mono", monospace';
                var step = (state.timeFormat === '24') ? 3 : 4;
                for (var tIdx = 0; tIdx < labels.length; tIdx += step) {
                    var lx = xScale(tIdx);
                    var txt = labels[tIdx] || '';
                    ctx.fillText(txt, lx, h - padB + 4);
                }
            }

            draw(null);

            var tooltip = document.getElementById('visibility-tooltip');
            var ttTime = document.getElementById('visibility-tooltip-time');
            var ttVal = document.getElementById('visibility-tooltip-val');

            function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
            function indexFromX(x) {
                var rel = (x - padL) / (w - padL - padR);
                var idx = Math.round(rel * (points.length - 1));
                return clamp(idx, 0, points.length - 1);
            }
            function placeTooltip(localX, localY) {
                if (!tooltip) return;
                var tw = 192;
                var th = 62;
                var x = localX + 12;
                var y = localY + 12;
                if (x + tw > w - 4) x = localX - tw - 12;
                if (y + th > h - 4) y = localY - th - 12;
                tooltip.style.left = x + 'px';
                tooltip.style.top = y + 'px';
            }

            function onMove(e) {
                var rect = canvas.getBoundingClientRect();
                var x = e.clientX - rect.left;
                var y = e.clientY - rect.top;
                var idx = indexFromX(x);

                draw(idx);

                if (tooltip) {
                    tooltip.classList.remove('hidden');
                    placeTooltip(x, y);
                }
                if (ttTime) ttTime.innerText = formatTime(times[idx]);
                if (ttVal) ttVal.innerText = (Math.round(points[idx] * 10) / 10).toFixed(1) + ' ' + unit;
            }

            function onLeave() {
                draw(null);
                if (tooltip) tooltip.classList.add('hidden');
            }

            if (canvas._mwVisMove) canvas.removeEventListener('mousemove', canvas._mwVisMove);
            if (canvas._mwVisLeave) canvas.removeEventListener('mouseleave', canvas._mwVisLeave);
            canvas._mwVisMove = onMove;
            canvas._mwVisLeave = onLeave;
            canvas.addEventListener('mousemove', onMove);
            canvas.addEventListener('mouseleave', onLeave);
        }

        function renderPressureChart() {
            if (!els.modalExtra) return;
            if (!state.weatherData || !state.weatherData.hourly) {
                els.modalExtra.innerHTML = '<div class="text-sm opacity-60">NO_HOURLY_DATA</div>';
                return;
            }

            var hourly = state.weatherData.hourly;
            if (!hourly.surface_pressure || !hourly.time) {
                els.modalExtra.innerHTML = '<div class="text-sm opacity-60">NO_PRESSURE_SERIES_AVAILABLE</div>';
                return;
            }

            // Build a series for the *current local day* (00:00–23:00), including past hours
            var points = [];
            var labels = [];
            var times = [];

            function formatChartHour(iso) {
                if (!iso || !iso.includes('T')) return '';
                var timePart = iso.split('T')[1] || '';
                if (state.timeFormat === '24') return timePart;
                var parts = timePart.split(':');
                var h = parseInt(parts[0], 10);
                var ampm = h >= 12 ? 'PM' : 'AM';
                h = h % 12;
                h = h ? h : 12;
                return `${h}${ampm}`;
            }

            var dayPrefix = (state.weatherData.current_weather && state.weatherData.current_weather.time)
                ? state.weatherData.current_weather.time.split('T')[0]
                : null;

            var dayIndices = [];
            if (dayPrefix) {
                for (var di = 0; di < hourly.time.length; di++) {
                    if (hourly.time[di] && hourly.time[di].startsWith(dayPrefix)) dayIndices.push(di);
                }
            }

            // Fallback: rolling 24h from current index
            if (dayIndices.length === 0) {
                var start = getHourlyIndex();
                for (var ri = start; ri < Math.min(start + 24, hourly.time.length); ri++) dayIndices.push(ri);
            }

            dayIndices = dayIndices.slice(0, 24);

            for (var ii = 0; ii < dayIndices.length; ii++) {
                var i = dayIndices[ii];
                var pVal = hourly.surface_pressure[i];
                points.push(pVal);
                var t = hourly.time[i];
                times.push(t);
                labels.push(formatChartHour(t));
            }

            // Current time marker index
            var nowIdx = -1;
            if (state.weatherData.current_weather && state.weatherData.current_weather.time) {
                var nowStr = state.weatherData.current_weather.time;
                nowIdx = times.findIndex(t => t === nowStr);
                if (nowIdx === -1) {
                    var nowPrefix = nowStr.substring(0, 13);
                    nowIdx = times.findIndex(t => t && t.startsWith(nowPrefix));
                }
            }

            els.modalExtra.innerHTML = `
                <div class="text-left w-full">
                    <div class="flex items-baseline justify-between gap-4 mb-2">
                        <div class="text-xs font-bold opacity-60 tracking-widest">TODAY_PRESSURE</div>
                        <div class="text-xs font-bold" style="color: rgb(234, 179, 8)">hPa</div>
                    </div>

                    <div class="relative">
                        <canvas id="pressure-chart" width="720" height="220" class="w-full h-44 border-2 border-[var(--text-color)] bg-transparent"></canvas>

                        <!-- Hover Tooltip -->
                        <div id="pressure-tooltip" class="hidden absolute z-30 pointer-events-none select-none bg-[var(--card-bg)] text-[var(--text-color)] border-2 border-[var(--text-color)] shadow-[4px_4px_0px_rgba(0,0,0,0.2)] px-3 py-2 text-xs w-44">
                            <div id="pressure-tooltip-time" class="font-bold opacity-60 tracking-widest">--:--</div>
                            <div class="mt-2">
                                <div class="text-[0.7rem] font-bold opacity-60">PRESSURE</div>
                                <div id="pressure-tooltip-val" class="text-lg font-bold leading-none" style="color: rgb(234, 179, 8)">--</div>
                            </div>
                        </div>
                    </div>

                    <div class="mt-2 text-[0.75rem] opacity-60 leading-snug">
                        HOVER_OVER_GRAPH_TO_HIGHLIGHT
                    </div>
                </div>
            `;

            var canvas = document.getElementById('pressure-chart');
            if (!canvas) return;
            var ctx = canvas.getContext('2d');
            if (!ctx) return;

            // High-DPI handling
            var dpr = window.devicePixelRatio || 1;
            var cssW = canvas.clientWidth;
            var cssH = canvas.clientHeight;
            canvas.width = Math.floor(cssW * dpr);
            canvas.height = Math.floor(cssH * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            var w = cssW;
            var h = cssH;
            var padL = 18;
            var padR = 10;
            var padT = 10;
            var padB = 26;

            var minV = Math.min.apply(null, points);
            var maxV = Math.max.apply(null, points);
            if (minV === maxV) {
                minV = minV - 2;
                maxV = maxV + 2;
            }
            var range = maxV - minV;
            minV -= range * 0.1;
            maxV += range * 0.1;

            function xScale(i) {
                if (points.length <= 1) return padL;
                return padL + (i * (w - padL - padR) / (points.length - 1));
            }
            function yScale(v) {
                return padT + (maxV - v) * (h - padT - padB) / (maxV - minV);
            }

            var textCol = (getComputedStyle(document.documentElement).getPropertyValue('--text-color') || '#111').trim();
            var gridCol = (getComputedStyle(document.documentElement).getPropertyValue('--card-border') || 'rgba(0,0,0,0.15)').trim();

            // Pressure palette
            var lineCol = 'rgba(234, 179, 8, 0.9)';
            var pointCol = 'rgba(234, 179, 8, 0.95)';

            function fillPressureBackground() {
                // Base theme background
                var bgCol = (getComputedStyle(document.documentElement).getPropertyValue('--bg-color') || '#ffffff').trim();
                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = bgCol;
                ctx.fillRect(0, 0, w, h);

                // Subtle vertical gradient overlay (dark yellow top -> light yellow bottom)
                var grad = ctx.createLinearGradient(0, 0, 0, h);
                grad.addColorStop(0, 'rgba(161, 98, 7, 0.20)');
                grad.addColorStop(1, 'rgba(254, 240, 138, 0.14)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, w, h);
            }

            function draw(hoverIdx) {
                fillPressureBackground();

                // Grid
                ctx.strokeStyle = gridCol;
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                var gridLines = 4;
                for (var g = 0; g <= gridLines; g++) {
                    var gy = padT + g * (h - padT - padB) / gridLines;
                    ctx.beginPath();
                    ctx.moveTo(padL, gy);
                    ctx.lineTo(w - padR, gy);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                // Axes
                ctx.strokeStyle = textCol;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padL, padT);
                ctx.lineTo(padL, h - padB);
                ctx.lineTo(w - padR, h - padB);
                ctx.stroke();

                // Line
                ctx.strokeStyle = lineCol;
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (var p = 0; p < points.length; p++) {
                    var x = xScale(p);
                    var y = yScale(points[p]);
                    if (p === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Points
                ctx.fillStyle = pointCol;
                for (var q = 0; q < points.length; q++) {
                    var px = xScale(q);
                    var py = yScale(points[q]);
                    ctx.beginPath();
                    ctx.arc(px, py, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Current hour marker
                if (nowIdx !== null && nowIdx !== undefined && nowIdx >= 0 && nowIdx < points.length) {
                    var nx = xScale(nowIdx);
                    ctx.save();
                    ctx.strokeStyle = textCol;
                    ctx.globalAlpha = 0.55;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6, 6]);
                    ctx.beginPath();
                    ctx.moveTo(nx, padT);
                    ctx.lineTo(nx, h - padB);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.restore();
                }

                // Hover highlight
                if (hoverIdx !== null && hoverIdx !== undefined) {
                    var hx = xScale(hoverIdx);
                    var hy = yScale(points[hoverIdx]);

                    ctx.strokeStyle = textCol;
                    ctx.globalAlpha = 0.35;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(hx, padT);
                    ctx.lineTo(hx, h - padB);
                    ctx.stroke();
                    ctx.globalAlpha = 1;

                    ctx.fillStyle = pointCol;
                    ctx.beginPath();
                    ctx.arc(hx, hy, 6, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = textCol;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(hx, hy, 6, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Y labels (min/max)
                ctx.fillStyle = textCol;
                ctx.font = 'bold 10px "Space Mono", monospace';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText(Math.round(maxV) + '', 6, padT + 6);
                ctx.fillText(Math.round(minV) + '', 6, h - padB - 6);

                // X labels
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.font = 'bold 9px "Space Mono", monospace';
                var step = (state.timeFormat === '24') ? 3 : 4;
                for (var tIdx = 0; tIdx < labels.length; tIdx += step) {
                    var lx = xScale(tIdx);
                    var txt = labels[tIdx] || '';
                    ctx.fillText(txt, lx, h - padB + 4);
                }
            }

            draw(null);

            var tooltip = document.getElementById('pressure-tooltip');
            var ttTime = document.getElementById('pressure-tooltip-time');
            var ttVal = document.getElementById('pressure-tooltip-val');

            function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
            function indexFromX(x) {
                var rel = (x - padL) / (w - padL - padR);
                var idx = Math.round(rel * (points.length - 1));
                return clamp(idx, 0, points.length - 1);
            }
            function placeTooltip(localX, localY) {
                if (!tooltip) return;
                var tw = 176;
                var th = 62;
                var x = localX + 12;
                var y = localY + 12;
                if (x + tw > w - 4) x = localX - tw - 12;
                if (y + th > h - 4) y = localY - th - 12;
                tooltip.style.left = x + 'px';
                tooltip.style.top = y + 'px';
            }

            function onMove(e) {
                var rect = canvas.getBoundingClientRect();
                var x = e.clientX - rect.left;
                var y = e.clientY - rect.top;
                var idx = indexFromX(x);

                draw(idx);

                if (tooltip) {
                    tooltip.classList.remove('hidden');
                    placeTooltip(x, y);
                }
                if (ttTime) ttTime.innerText = formatTime(times[idx]);
                if (ttVal) ttVal.innerText = Math.round(points[idx]) + ' hPa';
            }

            function onLeave() {
                draw(null);
                if (tooltip) tooltip.classList.add('hidden');
            }

            if (canvas._mwPressMove) canvas.removeEventListener('mousemove', canvas._mwPressMove);
            if (canvas._mwPressLeave) canvas.removeEventListener('mouseleave', canvas._mwPressLeave);
            canvas._mwPressMove = onMove;
            canvas._mwPressLeave = onLeave;
            canvas.addEventListener('mousemove', onMove);
            canvas.addEventListener('mouseleave', onLeave);
        }

        function renderPrecipChart() {
            if (!els.modalExtra) return;
            if (!state.weatherData || !state.weatherData.hourly) {
                els.modalExtra.innerHTML = '<div class="text-sm opacity-60">NO_HOURLY_DATA</div>';
                return;
            }

            var hourly = state.weatherData.hourly;
            if (!hourly.time) {
                els.modalExtra.innerHTML = '<div class="text-sm opacity-60">NO_PRECIP_SERIES_AVAILABLE</div>';
                return;
            }

            // Build a series for the *current local day* (00:00–23:00), including past hours
            var points = [];
            var labels = [];
            var times = [];

            var unit = (state.unit === 'f') ? 'in' : 'mm';

            function formatChartHour(iso) {
                if (!iso || !iso.includes('T')) return '';
                var timePart = iso.split('T')[1] || '';
                if (state.timeFormat === '24') return timePart;
                var parts = timePart.split(':');
                var h = parseInt(parts[0], 10);
                var ampm = h >= 12 ? 'PM' : 'AM';
                h = h % 12;
                h = h ? h : 12;
                return `${h}${ampm}`;
            }

            var dayPrefix = (state.weatherData.current_weather && state.weatherData.current_weather.time)
                ? state.weatherData.current_weather.time.split('T')[0]
                : null;

            var dayIndices = [];
            if (dayPrefix) {
                for (var di = 0; di < hourly.time.length; di++) {
                    if (hourly.time[di] && hourly.time[di].startsWith(dayPrefix)) dayIndices.push(di);
                }
            }

            // Fallback: rolling 24h from current index
            if (dayIndices.length === 0) {
                var start = getHourlyIndex();
                for (var ri = start; ri < Math.min(start + 24, hourly.time.length); ri++) dayIndices.push(ri);
            }

            dayIndices = dayIndices.slice(0, 24);

            for (var ii = 0; ii < dayIndices.length; ii++) {
                var i = dayIndices[ii];

                // Prefer aggregated precipitation (mm). If missing, sum rain+showers+snowfall.
                var pMm = null;
                if (hourly.precipitation && hourly.precipitation[i] !== undefined && hourly.precipitation[i] !== null) {
                    pMm = hourly.precipitation[i];
                } else {
                    var rain = (hourly.rain && hourly.rain[i] !== undefined) ? hourly.rain[i] : 0;
                    var showers = (hourly.showers && hourly.showers[i] !== undefined) ? hourly.showers[i] : 0;
                    var snow = (hourly.snowfall && hourly.snowfall[i] !== undefined) ? hourly.snowfall[i] : 0;
                    pMm = rain + showers + (snow * 10);
                }
                if (pMm === null || pMm === undefined || isNaN(pMm)) pMm = 0;

                var v = pMm;
                if (state.unit === 'f') v = pMm * 0.0393701; // inches

                points.push(v);

                var t = hourly.time[i];
                times.push(t);
                labels.push(formatChartHour(t));
            }

            // Current time marker index
            var nowIdx = -1;
            if (state.weatherData.current_weather && state.weatherData.current_weather.time) {
                var nowStr = state.weatherData.current_weather.time;
                nowIdx = times.findIndex(t => t === nowStr);
                if (nowIdx === -1) {
                    var nowPrefix = nowStr.substring(0, 13);
                    nowIdx = times.findIndex(t => t && t.startsWith(nowPrefix));
                }
            }

            els.modalExtra.innerHTML = `
                <div class="text-left w-full">
                    <div class="flex justify-end mb-3">
                        <button type="button" onclick="window.openRadarPreset('precip')" class="px-3 py-2 border-4 border-[var(--text-color)] bg-[var(--card-bg)] font-bold text-xs tracking-widest hover:bg-accent hover:text-white transition-colors">
                            OPEN_RADAR • PRECIP
                        </button>
                    </div>
                    <div class="flex items-baseline justify-between gap-4 mb-2">
                        <div class="text-xs font-bold opacity-60 tracking-widest">TODAY_PRECIPITATION</div>
                        <div class="text-xs font-bold" style="color: rgba(30, 64, 175, 0.95)">${unit}</div>
                    </div>

                    <div class="relative">
                        <canvas id="precip-chart" width="720" height="220" class="w-full h-44 border-2 border-[var(--text-color)] bg-transparent"></canvas>

                        <!-- Hover Tooltip -->
                        <div id="precip-tooltip" class="hidden absolute z-30 pointer-events-none select-none bg-[var(--card-bg)] text-[var(--text-color)] border-2 border-[var(--text-color)] shadow-[4px_4px_0px_rgba(0,0,0,0.2)] px-3 py-2 text-xs w-48">
                            <div id="precip-tooltip-time" class="font-bold opacity-60 tracking-widest">--:--</div>
                            <div class="mt-2">
                                <div class="text-[0.7rem] font-bold opacity-60">PRECIP</div>
                                <div id="precip-tooltip-val" class="text-lg font-bold leading-none" style="color: rgba(30, 64, 175, 0.95)">--</div>
                            </div>
                        </div>
                    </div>

                    <div class="mt-2 text-[0.75rem] opacity-60 leading-snug">
                        HOVER_OVER_GRAPH_TO_HIGHLIGHT
                    </div>
                </div>
            `;

            var canvas = document.getElementById('precip-chart');
            if (!canvas) return;
            var ctx = canvas.getContext('2d');
            if (!ctx) return;

            // High-DPI handling
            var dpr = window.devicePixelRatio || 1;
            var cssW = canvas.clientWidth;
            var cssH = canvas.clientHeight;
            canvas.width = Math.floor(cssW * dpr);
            canvas.height = Math.floor(cssH * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            var w = cssW;
            var h = cssH;
            var padL = 18;
            var padR = 10;
            var padT = 10;
            var padB = 26;

            // Precip is often 0-heavy; use 0..max for clarity
            var minV = 0;
            var maxV = Math.max.apply(null, points);
            if (!isFinite(maxV) || maxV <= 0) maxV = (state.unit === 'f') ? 0.5 : 10; // sane scale when dry
            maxV += maxV * 0.1;

            function xScale(i) {
                if (points.length <= 1) return padL;
                return padL + (i * (w - padL - padR) / (points.length - 1));
            }
            function yScale(v) {
                return padT + (maxV - v) * (h - padT - padB) / (maxV - minV);
            }

            var textCol = (getComputedStyle(document.documentElement).getPropertyValue('--text-color') || '#111').trim();
            var gridCol = (getComputedStyle(document.documentElement).getPropertyValue('--card-border') || 'rgba(0,0,0,0.15)').trim();

            // Precip palette
            var lineCol = 'rgba(30, 64, 175, 0.9)';
            var pointCol = 'rgba(30, 64, 175, 0.95)';

            function fillPrecipBackground() {
                // Base theme background
                var bgCol = (getComputedStyle(document.documentElement).getPropertyValue('--bg-color') || '#ffffff').trim();
                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = bgCol;
                ctx.fillRect(0, 0, w, h);

                // Subtle vertical gradient overlay (dark blue top -> light blue bottom)
                var grad = ctx.createLinearGradient(0, 0, 0, h);
                grad.addColorStop(0, 'rgba(30, 64, 175, 0.20)');
                grad.addColorStop(1, 'rgba(191, 219, 254, 0.14)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, w, h);
            }

            function draw(hoverIdx) {
                fillPrecipBackground();

                // Grid
                ctx.strokeStyle = gridCol;
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                var gridLines = 4;
                for (var g = 0; g <= gridLines; g++) {
                    var gy = padT + g * (h - padT - padB) / gridLines;
                    ctx.beginPath();
                    ctx.moveTo(padL, gy);
                    ctx.lineTo(w - padR, gy);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                // Axes
                ctx.strokeStyle = textCol;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padL, padT);
                ctx.lineTo(padL, h - padB);
                ctx.lineTo(w - padR, h - padB);
                ctx.stroke();

                // Line
                ctx.strokeStyle = lineCol;
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (var p = 0; p < points.length; p++) {
                    var x = xScale(p);
                    var y = yScale(points[p]);
                    if (p === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Points
                ctx.fillStyle = pointCol;
                for (var q = 0; q < points.length; q++) {
                    var px = xScale(q);
                    var py = yScale(points[q]);
                    ctx.beginPath();
                    ctx.arc(px, py, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Current hour marker
                if (nowIdx !== null && nowIdx !== undefined && nowIdx >= 0 && nowIdx < points.length) {
                    var nx = xScale(nowIdx);
                    ctx.save();
                    ctx.strokeStyle = textCol;
                    ctx.globalAlpha = 0.55;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6, 6]);
                    ctx.beginPath();
                    ctx.moveTo(nx, padT);
                    ctx.lineTo(nx, h - padB);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.restore();
                }

                // Hover highlight
                if (hoverIdx !== null && hoverIdx !== undefined) {
                    var hx = xScale(hoverIdx);
                    var hy = yScale(points[hoverIdx]);

                    ctx.strokeStyle = textCol;
                    ctx.globalAlpha = 0.35;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(hx, padT);
                    ctx.lineTo(hx, h - padB);
                    ctx.stroke();
                    ctx.globalAlpha = 1;

                    ctx.fillStyle = pointCol;
                    ctx.beginPath();
                    ctx.arc(hx, hy, 6, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = textCol;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(hx, hy, 6, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Y labels (0 / max)
                ctx.fillStyle = textCol;
                ctx.font = 'bold 10px "Space Mono", monospace';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText(maxV.toFixed(state.unit === 'f' ? 2 : 1), 6, padT + 6);
                ctx.fillText('0', 6, h - padB - 6);

                // X labels
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.font = 'bold 9px "Space Mono", monospace';
                var step = (state.timeFormat === '24') ? 3 : 4;
                for (var tIdx = 0; tIdx < labels.length; tIdx += step) {
                    var lx = xScale(tIdx);
                    var txt = labels[tIdx] || '';
                    ctx.fillText(txt, lx, h - padB + 4);
                }
            }

            draw(null);

            var tooltip = document.getElementById('precip-tooltip');
            var ttTime = document.getElementById('precip-tooltip-time');
            var ttVal = document.getElementById('precip-tooltip-val');

            function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
            function indexFromX(x) {
                var rel = (x - padL) / (w - padL - padR);
                var idx = Math.round(rel * (points.length - 1));
                return clamp(idx, 0, points.length - 1);
            }
            function placeTooltip(localX, localY) {
                if (!tooltip) return;
                var tw = 192;
                var th = 62;
                var x = localX + 12;
                var y = localY + 12;
                if (x + tw > w - 4) x = localX - tw - 12;
                if (y + th > h - 4) y = localY - th - 12;
                tooltip.style.left = x + 'px';
                tooltip.style.top = y + 'px';
            }

            function onMove(e) {
                var rect = canvas.getBoundingClientRect();
                var x = e.clientX - rect.left;
                var y = e.clientY - rect.top;
                var idx = indexFromX(x);

                draw(idx);

                if (tooltip) {
                    tooltip.classList.remove('hidden');
                    placeTooltip(x, y);
                }
                if (ttTime) ttTime.innerText = formatTime(times[idx]);
                if (ttVal) ttVal.innerText = points[idx].toFixed(state.unit === 'f' ? 2 : 1) + ' ' + unit;
            }

            function onLeave() {
                draw(null);
                if (tooltip) tooltip.classList.add('hidden');
            }

            if (canvas._mwPrecipMove) canvas.removeEventListener('mousemove', canvas._mwPrecipMove);
            if (canvas._mwPrecipLeave) canvas.removeEventListener('mouseleave', canvas._mwPrecipLeave);
            canvas._mwPrecipMove = onMove;
            canvas._mwPrecipLeave = onLeave;
            canvas.addEventListener('mousemove', onMove);
            canvas.addEventListener('mouseleave', onLeave);
        }

        function renderTempChart() {
            if (!els.modalExtra) return;
            if (!state.weatherData || !state.weatherData.hourly || !state.weatherData.daily) {
                els.modalExtra.innerHTML = '<div class="text-sm opacity-60">NO_HOURLY_DATA</div>';
                return;
            }

            var hourly = state.weatherData.hourly;
            var daily = state.weatherData.daily;
            if (!hourly.temperature_2m || !hourly.apparent_temperature || !hourly.time) {
                els.modalExtra.innerHTML = '<div class="text-sm opacity-60">NO_TEMPERATURE_SERIES_AVAILABLE</div>';
                return;
            }

            var unit = (state.unit === 'f') ? '°F' : '°C';

            // Build a series for the *current local day* (00:00–23:00), including past hours
            var realPts = [];
            var feelPts = [];
            var labels = [];
            var times = [];

            function formatChartHour(iso) {
                if (!iso || !iso.includes('T')) return '';
                var timePart = iso.split('T')[1] || '';
                if (state.timeFormat === '24') return timePart;
                var parts = timePart.split(':');
                var h = parseInt(parts[0], 10);
                var ampm = h >= 12 ? 'PM' : 'AM';
                h = h % 12;
                h = h ? h : 12;
                return `${h}${ampm}`;
            }

            var dayPrefix = (state.weatherData.current_weather && state.weatherData.current_weather.time)
                ? state.weatherData.current_weather.time.split('T')[0]
                : null;

            var dayIndices = [];
            if (dayPrefix) {
                for (var di = 0; di < hourly.time.length; di++) {
                    if (hourly.time[di] && hourly.time[di].startsWith(dayPrefix)) dayIndices.push(di);
                }
            }
            if (dayIndices.length === 0) {
                var start = getHourlyIndex();
                for (var ri = start; ri < Math.min(start + 24, hourly.time.length); ri++) dayIndices.push(ri);
            }
            dayIndices = dayIndices.slice(0, 24);

            for (var ii = 0; ii < dayIndices.length; ii++) {
                var i = dayIndices[ii];
                var tC = hourly.temperature_2m[i];
                var fC = (hourly.apparent_temperature && hourly.apparent_temperature[i] !== undefined)
                    ? hourly.apparent_temperature[i]
                    : tC;

                // Guard against missing/invalid apparent_temperature values
                if (fC === null || fC === undefined || isNaN(fC)) fC = tC;

                var t = tC;
                var f = fC;
                if (state.unit === 'f') {
                    t = (t * 9/5) + 32;
                    f = (f * 9/5) + 32;
                }

                realPts.push(t);
                feelPts.push(f);
                times.push(hourly.time[i]);
                labels.push(formatChartHour(hourly.time[i]));
            }

            // Today high/low (from daily)
            var hi = daily.temperature_2m_max && daily.temperature_2m_max[0] !== undefined ? daily.temperature_2m_max[0] : null;
            var lo = daily.temperature_2m_min && daily.temperature_2m_min[0] !== undefined ? daily.temperature_2m_min[0] : null;
            if (hi !== null && state.unit === 'f') hi = (hi * 9/5) + 32;
            if (lo !== null && state.unit === 'f') lo = (lo * 9/5) + 32;

            // Find indices of actual (hourly) high/low for highlighting points
            var hiIdx = 0;
            var loIdx = 0;
            for (var k = 0; k < realPts.length; k++) {
                if (realPts[k] > realPts[hiIdx]) hiIdx = k;
                if (realPts[k] < realPts[loIdx]) loIdx = k;
            }

            // Current hour marker index
            var nowIdx = -1;
            if (state.weatherData.current_weather && state.weatherData.current_weather.time) {
                var nowStr = state.weatherData.current_weather.time;
                nowIdx = times.findIndex(t => t === nowStr);
                if (nowIdx === -1) {
                    var nowPrefix = nowStr.substring(0, 13);
                    nowIdx = times.findIndex(t => t && t.startsWith(nowPrefix));
                }
            }

            els.modalExtra.innerHTML = `
                <div class="text-left w-full">
                    <div class="flex justify-end mb-3">
                        <button type="button" onclick="window.openRadarPreset('temp')" class="px-3 py-2 border-4 border-[var(--text-color)] bg-[var(--card-bg)] font-bold text-xs tracking-widest hover:bg-accent hover:text-white transition-colors">
                            OPEN_RADAR • TEMP
                        </button>
                    </div>
                    <div class="flex items-baseline justify-between gap-4 mb-2">
                        <div class="text-xs font-bold opacity-60 tracking-widest">TODAY_TEMPERATURE</div>
                        <div class="text-xs font-bold" style="color: var(--accent-color)">${unit}</div>
                    </div>

                    <div class="flex items-center gap-4 text-[0.7rem] font-bold opacity-70 mb-2">
                        <div class="flex items-center gap-2"><span class="inline-block w-4 h-[3px]" style="background:#cbd5e1"></span>REAL</div>
                        <div class="flex items-center gap-2"><span class="inline-block w-4 h-[3px]" style="background:#86efac"></span>FEELS</div>
                    </div>

                    <div class="relative">
                        <canvas id="temp-chart" width="720" height="220" class="w-full h-44 border-2 border-[var(--text-color)] bg-transparent"></canvas>

                        <div id="temp-tooltip" class="hidden absolute z-30 pointer-events-none select-none bg-[var(--card-bg)] text-[var(--text-color)] border-2 border-[var(--text-color)] shadow-[4px_4px_0px_rgba(0,0,0,0.2)] px-3 py-2 text-xs w-56">
                            <div id="temp-tooltip-time" class="font-bold opacity-60 tracking-widest">--:--</div>
                            <div class="mt-2 grid grid-cols-2 gap-3">
                                <div>
                                    <div class="text-[0.7rem] font-bold opacity-60">REAL</div>
                                    <div id="temp-tooltip-real" class="text-lg font-bold leading-none" style="color:#cbd5e1">--</div>
                                </div>
                                <div>
                                    <div class="text-[0.7rem] font-bold opacity-60">FEELS</div>
                                    <div id="temp-tooltip-feels" class="text-lg font-bold leading-none" style="color:#86efac">--</div>
                                </div>
                            </div>
                            <div class="mt-2 text-[0.7rem] font-bold opacity-60">
                                HIGH: <span id="temp-tooltip-high">--</span> • LOW: <span id="temp-tooltip-low">--</span>
                            </div>
                        </div>
                    </div>

                    <div class="mt-2 text-[0.75rem] opacity-60 leading-snug">
                        HOVER_OVER_GRAPH_TO_HIGHLIGHT
                    </div>
                </div>
            `;

            var canvas = document.getElementById('temp-chart');
            if (!canvas) return;
            var ctx = canvas.getContext('2d');
            if (!ctx) return;

            var tooltip = document.getElementById('temp-tooltip');
            var ttTime = document.getElementById('temp-tooltip-time');
            var ttReal = document.getElementById('temp-tooltip-real');
            var ttFeels = document.getElementById('temp-tooltip-feels');
            var ttHigh = document.getElementById('temp-tooltip-high');
            var ttLow = document.getElementById('temp-tooltip-low');

            // High-DPI handling
            var dpr = window.devicePixelRatio || 1;
            var cssW = canvas.clientWidth;
            var cssH = canvas.clientHeight;
            canvas.width = Math.floor(cssW * dpr);
            canvas.height = Math.floor(cssH * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            var w = cssW;
            var h = cssH;
            var padL = 18;
            var padR = 10;
            var padT = 10;
            var padB = 26;

            function minArr(a) { return Math.min.apply(null, a); }
            function maxArr(a) { return Math.max.apply(null, a); }

            var minV = Math.min(minArr(realPts), minArr(feelPts));
            var maxV = Math.max(maxArr(realPts), maxArr(feelPts));
            if (hi !== null) maxV = Math.max(maxV, hi);
            if (lo !== null) minV = Math.min(minV, lo);

            if (minV === maxV) {
                minV -= 5;
                maxV += 5;
            }
            var range = maxV - minV;
            minV -= range * 0.12;
            maxV += range * 0.12;

            function xScale(i) {
                if (realPts.length <= 1) return padL;
                return padL + (i * (w - padL - padR) / (realPts.length - 1));
            }
            function yScale(v) {
                return padT + (maxV - v) * (h - padT - padB) / (maxV - minV);
            }

            var accent = (getComputedStyle(document.documentElement).getPropertyValue('--accent-color') || '#f97316').trim();
            var textCol = (getComputedStyle(document.documentElement).getPropertyValue('--text-color') || '#111').trim();
            var gridCol = (getComputedStyle(document.documentElement).getPropertyValue('--card-border') || 'rgba(0,0,0,0.15)').trim();

            var realLineCol = '#cbd5e1';
            var feelsLineCol = '#86efac';

            function fillBackground() {
                // Base theme background
                var bgCol = (getComputedStyle(document.documentElement).getPropertyValue('--bg-color') || '#ffffff').trim();
                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = bgCol;
                ctx.fillRect(0, 0, w, h);

                // Subtle vertical gradient overlay (red top -> blue bottom)
                var grad = ctx.createLinearGradient(0, 0, 0, h);
                grad.addColorStop(0, 'rgba(239, 68, 68, 0.16)');  // red (faded)
                grad.addColorStop(1, 'rgba(59, 130, 246, 0.14)'); // blue (faded)
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, w, h);
            }

            function drawHighLowLines() {
                ctx.save();
                ctx.setLineDash([6, 6]);
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.35;
                ctx.strokeStyle = textCol;

                if (hi !== null && hi !== undefined) {
                    var yH = yScale(hi);
                    ctx.beginPath();
                    ctx.moveTo(padL, yH);
                    ctx.lineTo(w - padR, yH);
                    ctx.stroke();
                }
                if (lo !== null && lo !== undefined) {
                    var yL = yScale(lo);
                    ctx.beginPath();
                    ctx.moveTo(padL, yL);
                    ctx.lineTo(w - padR, yL);
                    ctx.stroke();
                }
                ctx.restore();
            }

            function drawSeriesLine(series, color) {
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (var p = 0; p < series.length; p++) {
                    var x = xScale(p);
                    var y = yScale(series[p]);
                    if (p === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            function drawSeriesPoints(series, color) {
                ctx.fillStyle = color;
                for (var q = 0; q < series.length; q++) {
                    var px = xScale(q);
                    var py = yScale(series[q]);
                    ctx.beginPath();
                    ctx.arc(px, py, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            function drawSpecialPoint(idx, value, fillCol) {
                var x = xScale(idx);
                var y = yScale(value);
                ctx.fillStyle = fillCol;
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = textCol;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, Math.PI * 2);
                ctx.stroke();
            }

            function draw(hoverIdx) {
                fillBackground();

                // Grid
                ctx.strokeStyle = gridCol;
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                var gridLines = 4;
                for (var g = 0; g <= gridLines; g++) {
                    var gy = padT + g * (h - padT - padB) / gridLines;
                    ctx.beginPath();
                    ctx.moveTo(padL, gy);
                    ctx.lineTo(w - padR, gy);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                // Axes
                ctx.strokeStyle = textCol;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padL, padT);
                ctx.lineTo(padL, h - padB);
                ctx.lineTo(w - padR, h - padB);
                ctx.stroke();

                // High/Low dashed lines
                drawHighLowLines();

                // Series
                drawSeriesLine(realPts, realLineCol);
                drawSeriesLine(feelPts, feelsLineCol);
                drawSeriesPoints(realPts, realLineCol);
                drawSeriesPoints(feelPts, feelsLineCol);

                // Highlight hourly max/min points on REAL
                if (realPts.length) {
                    drawSpecialPoint(hiIdx, realPts[hiIdx], realLineCol);
                    drawSpecialPoint(loIdx, realPts[loIdx], realLineCol);
                }

                // NOW marker
                if (nowIdx !== null && nowIdx !== undefined && nowIdx >= 0 && nowIdx < realPts.length) {
                    var nx = xScale(nowIdx);
                    ctx.save();
                    ctx.strokeStyle = textCol;
                    ctx.globalAlpha = 0.55;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6, 6]);
                    ctx.beginPath();
                    ctx.moveTo(nx, padT);
                    ctx.lineTo(nx, h - padB);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.restore();
                }

                // Hover
                if (hoverIdx !== null && hoverIdx !== undefined) {
                    var hx = xScale(hoverIdx);
                    ctx.save();
                    ctx.strokeStyle = textCol;
                    ctx.globalAlpha = 0.35;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(hx, padT);
                    ctx.lineTo(hx, h - padB);
                    ctx.stroke();
                    ctx.restore();

                    // Hover circles for both series
                    drawSpecialPoint(hoverIdx, realPts[hoverIdx], realLineCol);
                    drawSpecialPoint(hoverIdx, feelPts[hoverIdx], feelsLineCol);
                }

                // Y labels (min/max)
                ctx.fillStyle = textCol;
                ctx.font = 'bold 10px "Space Mono", monospace';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText(Math.round(maxV) + '', 6, padT + 6);
                ctx.fillText(Math.round(minV) + '', 6, h - padB - 6);

                // X labels
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.font = 'bold 9px "Space Mono", monospace';
                var step = (state.timeFormat === '24') ? 3 : 4;
                for (var tIdx = 0; tIdx < labels.length; tIdx += step) {
                    var lx = xScale(tIdx);
                    var txt = labels[tIdx] || '';
                    ctx.fillText(txt, lx, h - padB + 4);
                }
            }

            function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
            function indexFromX(x) {
                var rel = (x - padL) / (w - padL - padR);
                var idx = Math.round(rel * (realPts.length - 1));
                return clamp(idx, 0, realPts.length - 1);
            }

            function placeTooltip(localX, localY) {
                if (!tooltip) return;
                var tw = 224;
                var th = 96;
                var x = localX + 12;
                var y = localY + 12;
                if (x + tw > w - 4) x = localX - tw - 12;
                if (y + th > h - 4) y = localY - th - 12;
                tooltip.style.left = x + 'px';
                tooltip.style.top = y + 'px';
            }

            function onMove(e) {
                var rect = canvas.getBoundingClientRect();
                var x = e.clientX - rect.left;
                var y = e.clientY - rect.top;
                var idx = indexFromX(x);

                draw(idx);

                if (tooltip) {
                    tooltip.classList.remove('hidden');
                    placeTooltip(x, y);
                }
                if (ttTime) ttTime.innerText = formatTime(times[idx]);
                if (ttReal) ttReal.innerText = Math.round(realPts[idx]) + unit;
                if (ttFeels) ttFeels.innerText = Math.round(feelPts[idx]) + unit;
                if (ttHigh) ttHigh.innerText = (hi !== null && hi !== undefined) ? (Math.round(hi) + unit) : '--';
                if (ttLow) ttLow.innerText = (lo !== null && lo !== undefined) ? (Math.round(lo) + unit) : '--';
            }

            function onLeave() {
                draw(null);
                if (tooltip) tooltip.classList.add('hidden');
            }

            // Initial draw
            draw(null);

            if (canvas._mwTempMove) canvas.removeEventListener('mousemove', canvas._mwTempMove);
            if (canvas._mwTempLeave) canvas.removeEventListener('mouseleave', canvas._mwTempLeave);
            canvas._mwTempMove = onMove;
            canvas._mwTempLeave = onLeave;
            canvas.addEventListener('mousemove', onMove);
            canvas.addEventListener('mouseleave', onLeave);
        }

        function showDetail(title, value, desc, icon) {
            els.modalTitle.innerText = title;
            // Default reset
            els.modalValue.className = 'text-5xl md:text-6xl font-bold text-accent mb-6 break-words max-w-full';
            els.modalValue.innerText = '';
            els.modalDesc.innerText = desc;
            if (els.modalExtra) els.modalExtra.innerHTML = '';

            // Handle icon (wi vs px)
            if(icon && icon.includes('wi ')) {
                els.modalIcon.innerHTML = `<i class="${icon} text-6xl text-accent"></i>`;
            } else {
                els.modalIcon.innerHTML = icon ? `<i class="px ${icon} text-6xl text-accent"></i>` : '';
            }

            // Special formatting for TEMPERATURE modal
            if (title === 'TEMPERATURE') {
                var unit = (state.unit === 'f') ? '°F' : '°C';

                // Compute from source data to avoid stale/incorrect DOM values
                var current = '--';
                var feels = '--';
                var high = '--';
                var low  = '--';
                try {
                    if (state.weatherData && state.weatherData.current_weather && state.weatherData.hourly && state.weatherData.daily) {
                        var hIdx = getHourlyIndex();
                        var curC = state.weatherData.current_weather.temperature;
                        var feelsC = (state.weatherData.hourly.apparent_temperature && state.weatherData.hourly.apparent_temperature[hIdx] !== undefined)
                            ? state.weatherData.hourly.apparent_temperature[hIdx]
                            : curC;
                        if (feelsC === null || feelsC === undefined || isNaN(feelsC)) feelsC = curC;

                        var hiC = (state.weatherData.daily.temperature_2m_max && state.weatherData.daily.temperature_2m_max[0] !== undefined)
                            ? state.weatherData.daily.temperature_2m_max[0]
                            : null;
                        var loC = (state.weatherData.daily.temperature_2m_min && state.weatherData.daily.temperature_2m_min[0] !== undefined)
                            ? state.weatherData.daily.temperature_2m_min[0]
                            : null;

                        function toUnitTemp(c) { return (state.unit === 'f') ? (c * 9/5) + 32 : c; }

                        current = String(Math.round(toUnitTemp(curC)));
                        feels = String(Math.round(toUnitTemp(feelsC)));
                        if (hiC !== null && hiC !== undefined) high = String(Math.round(toUnitTemp(hiC)));
                        if (loC !== null && loC !== undefined) low = String(Math.round(toUnitTemp(loC)));
                    }
                } catch (e) {}

                // Use a dedicated layout (don’t inherit the default big accent paragraph styling)
                var deltaTxt = '--';
                try {
                    var curN = parseInt(current, 10);
                    var feelN = parseInt(feels, 10);
                    if (!isNaN(curN) && !isNaN(feelN)) {
                        var d = feelN - curN;
                        deltaTxt = (d > 0 ? '+' : '') + d + unit;
                    }
                } catch (e) {}

                els.modalValue.className = 'w-full mb-6';
                els.modalValue.innerHTML = `
                    <div class="w-full">
                        <!-- Big numbers -->
                        <div class="flex items-end justify-between gap-6">
                            <div class="text-left">
                                <div class="text-xs font-bold opacity-60 tracking-widest">CURRENT</div>
                                <div class="text-6xl md:text-7xl font-bold leading-none tracking-tighter">
                                    ${current}<span class="text-3xl md:text-4xl font-bold opacity-70 ml-1">${unit}</span>
                                </div>
                            </div>

                            <div class="text-right">
                                <div class="text-xs font-bold opacity-60 tracking-widest">FEELS</div>
                                <div class="text-6xl md:text-7xl font-bold leading-none tracking-tighter text-accent">
                                    ${feels}<span class="text-3xl md:text-4xl font-bold opacity-70 ml-1">${unit}</span>
                                </div>
                            </div>
                        </div>

                        <!-- Delta -->
                        <div class="mt-3 flex items-center justify-between">
                            <div class="text-xs font-bold opacity-60 tracking-widest">DELTA</div>
                            <div class="text-sm md:text-base font-bold opacity-80">${deltaTxt}</div>
                        </div>

                        <!-- High/Low (smaller) -->
                        <div class="mt-4 border-t-2 border-[var(--card-border)] pt-3">
                            <div class="flex items-center justify-between gap-6 text-sm md:text-base font-bold">
                                <div class="flex items-baseline gap-2">
                                    <span class="opacity-60 tracking-widest text-xs">HIGH</span>
                                    <span class="leading-none">${high}${unit}</span>
                                </div>
                                <div class="flex items-baseline gap-2 opacity-70">
                                    <span class="opacity-60 tracking-widest text-xs">LOW</span>
                                    <span class="leading-none">${low}${unit}</span>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                // Default behavior
                els.modalValue.innerText = value;
            }

            els.modal.showModal();

            // Render extras after opening (ensures canvas has layout size)
            if (title === 'WIND') {
                requestAnimationFrame(renderWindChart);
            }
            if (title === 'TEMPERATURE') {
                requestAnimationFrame(renderTempChart);
            }
            if (title === 'HUMIDITY') {
                requestAnimationFrame(renderHumidityChart);
            }
            if (title === 'UV INDEX') {
                requestAnimationFrame(renderUVChart);
            }
            if (title === 'VISIBILITY') {
                requestAnimationFrame(renderVisibilityChart);
            }
            if (title === 'PRESSURE') {
                requestAnimationFrame(renderPressureChart);
            }
            if (title === 'PRECIPITATION') {
                requestAnimationFrame(renderPrecipChart);
            }
        }
        window.showDetail = showDetail;
        window.closeModal = () => {
            if (els.modalExtra) els.modalExtra.innerHTML = '';
            els.modal.close();
        };

        // Quick-jump: open RADAR with specific layers enabled/disabled
        // preset = 'precip' -> PRECIP ON, TEMP OFF
        // preset = 'temp'   -> PRECIP OFF, TEMP ON
        window.openRadarPreset = function(preset) {
            try { window.closeModal(); } catch (e) {}

            // Go to Radar page
            try { window.setPage(1); } catch (e) {}

            requestAnimationFrame(function(){
                try { initRadar(); } catch (e) {}

                if (preset === 'temp') {
                    state.radar.precipEnabled = false;
                    state.radar.tempEnabled = true;
                } else {
                    state.radar.precipEnabled = true;
                    state.radar.tempEnabled = false;
                }

                try { syncRadarLayerButtons(); } catch (e) {}
                try { updateRadarLayer(); } catch (e) {}
                try { updateTempLayer(true); } catch (e) {}
            });
        };

        function showDailyDetail(idx) {
            var daily = state.weatherData.daily;
            var code = daily.weathercode[idx];
            var info = weatherCodeMap[code];
            var dateStr = new Date(daily.time[idx]).toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' }).toUpperCase();
            
            let min = daily.temperature_2m_min[idx];
            let max = daily.temperature_2m_max[idx];
            if(state.unit === 'f') {
                min = (min * 9/5) + 32;
                max = (max * 9/5) + 32;
            }

            var valText = `${Math.round(max)}° / ${Math.round(min)}°`;
            var descText = `${info.desc}. Sunrise: ${formatTime(daily.sunrise[idx])}. Sunset: ${formatTime(daily.sunset[idx])}. UV Max: ${daily.uv_index_max[idx]}.`;

            showDetail(dateStr, valText, descText, info.icon);
        }

        // Start
        init();

    </script>
</body>
</html>
